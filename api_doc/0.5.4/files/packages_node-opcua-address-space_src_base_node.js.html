<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="flattr:id" content="me93y1">


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J4DZPPT47Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-J4DZPPT47Y');
</script>


    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-N63SL9Q');</script>
    <!-- End Google Tag Manager -->

    <title>packages\node-opcua-address-space\src\base_node.js - The NodeOPCUA API</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">


    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-8886208393040088",
            enable_page_level_ads: true
        });
    </script>

</head>
<body class="yui3-skin-sam">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N63SL9Q"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="The NodeOPCUA API" src="../assets/css/logo.png" style="max-height: 65%;" title="The NodeOPCUA API">
            The NodeOPCUA API
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.5.4</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/AcknowledgeMessage", "classes/ActivateSessionRequest", "classes/ActivateSessionResponse", "classes/AddNodesItem", "classes/AddNodesRequest", "classes/AddNodesResponse", "classes/AddNodesResult", "classes/AddReferencesItem", "classes/AddReferencesRequest", "classes/AddReferencesResponse", "classes/AddressSpace", "classes/AggregateConfiguration", "classes/AggregateFilter", "classes/AnonymousIdentityToken", "classes/ApplicationDescription", "classes/ApplicationInstanceCertificate", "classes/Argument", "classes/AsymmetricAlgorithmSecurityHeader", "classes/AttributeIds", "classes/AttributeNameById", "classes/AttributeOperand", "classes/AxisInformation", "classes/BaseEventType", "classes/BaseNode", "classes/BaseUAObject", "classes/BinaryStream", "classes/BinaryStreamSizeCalculator", "classes/BrowseDescription", "classes/BrowseDirection", "classes/BrowseNextRequest", "classes/BrowseNextResponse", "classes/BrowsePath", "classes/BrowsePathResult", "classes/BrowsePathTarget", "classes/BrowseRequest", "classes/BrowseResponse", "classes/BrowseResult", "classes/BuildInfo", "classes/CallMethodRequest", "classes/CallMethodResult", "classes/CallRequest", "classes/CallResponse", "classes/CancelRequest", "classes/CancelResponse", "classes/ChannelSecurityToken", "classes/ChunkManager", "classes/ClientMonitoredItem", "classes/ClientMonitoredItemGroup", "classes/ClientSecureChannelLayer", "classes/ClientSession", "classes/ClientSidePublishEngine", "classes/ClientSubscription", "classes/ClientTCP_transport", "classes/CloseSecureChannelRequest", "classes/CloseSecureChannelResponse", "classes/CloseSessionRequest", "classes/CloseSessionResponse", "classes/ConditionInfo", "classes/ConditionSnapshot", "classes/ContentFilter", "classes/ContentFilterElement", "classes/ContentFilterElementResult", "classes/ContentFilterResult", "classes/CreateMonitoredItemsRequest", "classes/CreateMonitoredItemsResponse", "classes/CreateSessionRequest", "classes/CreateSessionResponse", "classes/CreateSubscriptionRequest", "classes/CreateSubscriptionResponse", "classes/DataChangeFilter", "classes/DataChangeNotification", "classes/DataValue", "classes/DeleteMonitoredItemsRequest", "classes/DeleteMonitoredItemsResponse", "classes/DeleteNodesItem", "classes/DeleteNodesRequest", "classes/DeleteNodesResponse", "classes/DeleteReferencesItem", "classes/DeleteReferencesRequest", "classes/DeleteReferencesResponse", "classes/DeleteSubscriptionsRequest", "classes/DeleteSubscriptionsResponse", "classes/DiagnosticInfo", "classes/ElementOperand", "classes/EndpointDescription", "classes/Enum", "classes/EnumValueType", "classes/ErrorMessage", "classes/EUInformation", "classes/EventData", "classes/EventFieldList", "classes/EventFilter", "classes/EventFilterResult", "classes/EventNotificationList", "classes/ExpandedNodeId", "classes/Factory", "classes/FilterOperand", "classes/FindServersOnNetworkRequest", "classes/FindServersOnNetworkResponse", "classes/FindServersRequest", "classes/FindServersResponse", "classes/GetEndpointsRequest", "classes/GetEndpointsResponse", "classes/HelloMessage", "classes/HistoryData", "classes/HistoryModifiedData", "classes/HistoryReadDetails", "classes/HistoryReadRequest", "classes/HistoryReadResponse", "classes/HistoryReadResult", "classes/HistoryReadValueId", "classes/HistoryServerCapabilities", "classes/HistoryUpdateRequest", "classes/HistoryUpdateResponse", "classes/HistoryUpdateResult", "classes/IssuedIdentityToken", "classes/LiteralOperand", "classes/LocalizedText", "classes/MandatoryChildOrRequestedOptionalFilter", "classes/MdnsDiscoveryConfiguration", "classes/MessageBuilder", "classes/MessageBuilderBase", "classes/MessageChunker", "classes/ModelChangeStructure", "classes/ModificationInfo", "classes/ModifyMonitoredItemsRequest", "classes/ModifyMonitoredItemsResponse", "classes/ModifySubscriptionRequest", "classes/ModifySubscriptionResponse", "classes/MonitoredItem", "classes/MonitoredItemCreateRequest", "classes/MonitoredItemCreateResult", "classes/MonitoredItemModifyRequest", "classes/MonitoredItemModifyResult", "classes/MonitoredItemNotification", "classes/MonitoringFilter", "classes/MonitoringParameters", "classes/NodeCrawler", "classes/NodeId", "classes/NodeIdType", "classes/NodeTypeDescription", "classes/NotificationMessage", "classes/opcua", "classes/OPCUABaseServer", "classes/OPCUAClient", "classes/OPCUAClientBase", "classes/OPCUASecureObject", "classes/OPCUAServer", "classes/OPCUAServerEndPoint", "classes/OpenSecureChannelRequest", "classes/OpenSecureChannelResponse", "classes/OperationLimits", "classes/PacketAssembler", "classes/ParsingResult", "classes/PublishRequest", "classes/PublishResponse", "classes/QualifiedName", "classes/QueryDataDescription", "classes/QueryDataSet", "classes/QueryFirstRequest", "classes/QueryFirstResponse", "classes/QueryNextRequest", "classes/QueryNextResponse", "classes/Range", "classes/ReadAtTimeDetails", "classes/ReaderState", "classes/ReadEventDetails", "classes/ReadProcessedDetails", "classes/ReadRawModifiedDetails", "classes/ReadRequest", "classes/ReadResponse", "classes/ReadValueId", "classes/RedundantServer", "classes/Reference", "classes/ReferenceDescription", "classes/ReferenceType", "classes/RegisteredServer", "classes/RegisterNodesRequest", "classes/RegisterNodesResponse", "classes/RegisterServer2Request", "classes/RegisterServer2Response", "classes/RegisterServerRequest", "classes/RegisterServerResponse", "classes/RelativePath", "classes/RelativePathElement", "classes/RepublishRequest", "classes/RepublishResponse", "classes/RequestHeader", "classes/ResponseHeader", "classes/SamplingIntervalDiagnostics", "classes/SecureMessageChunkManager", "classes/SecurityPolicy", "classes/SemanticChangeStructure", "classes/SequenceHeader", "classes/SequenceNumberGenerator", "classes/ServerCapabilities", "classes/ServerDiagnosticsSummary", "classes/ServerEngine", "classes/ServerOnNetwork", "classes/ServerSecureChannelLayer", "classes/ServerSession", "classes/ServerSidePublishEngine", "classes/ServerStatus", "classes/ServerTCP_transport", "classes/ServiceCounter", "classes/ServiceFault", "classes/SessionContext", "classes/SessionDiagnostics", "classes/SessionSecurityDiagnostics", "classes/SetMonitoringModeRequest", "classes/SetMonitoringModeResponse", "classes/SetPublishingModeRequest", "classes/SetPublishingModeResponse", "classes/SetTriggeringRequest", "classes/SetTriggeringResponse", "classes/SignatureData", "classes/SignedSoftwareCertificate", "classes/SimpleAttributeOperand", "classes/Simulator", "classes/StatusChangeNotification", "classes/StatusCode", "classes/Subscription", "classes/SubscriptionAcknowledgement", "classes/SubscriptionDiagnostics", "classes/SymmetricAlgorithmSecurityHeader", "classes/TCP_transport", "classes/TCPErrorMessage", "classes/TimestampsToReturn", "classes/TimeZone", "classes/ToolBrowsePath", "classes/TransferResult", "classes/TransferSubscriptionsRequest", "classes/TransferSubscriptionsResponse", "classes/TranslateBrowsePathsToNodeIdsRequest", "classes/TranslateBrowsePathsToNodeIdsResponse", "classes/TypeSchema", "classes/UAAcknowledgeableConditionBase", "classes/UAAlarmConditionBase", "classes/UACertificateExpirationAlarm", "classes/UAConditionBase", "classes/UADataType", "classes/UADiscreteAlarm", "classes/UAExclusiveDeviationAlarm", "classes/UAExclusiveLevelAlarm", "classes/UAExclusiveLimitAlarm", "classes/UAExclusiveRateOfChangeAlarm", "classes/UALimitAlarm", "classes/UAMultiStateDiscreteType", "classes/UANonExclusiveDeviationAlarm", "classes/UANonExclusiveLimitAlarm", "classes/UAObject", "classes/UAObjectType", "classes/UAOffNormalAlarm", "classes/UAProxyManager", "classes/UASystemOffNormalAlarm", "classes/UATripAlarm", "classes/UATwoStateVariable", "classes/UAVariable", "classes/UAVariableType", "classes/UnregisterNodesRequest", "classes/UnregisterNodesResponse", "classes/UserNameIdentityToken", "classes/UserTokenPolicy", "classes/Variant", "classes/View", "classes/ViewDescription", "classes/WriteRequest", "classes/WriteResponse", "classes/WriteValue", "classes/X509IdentityToken", "classes/Xml2Json", "modules/opcua.address_space", "modules/opcua.address_space.AlarmsAndConditions", "modules/opcua.address_space.types", "modules/opcua.client", "modules/opcua.data-value", "modules/opcua.datamodel", "modules/opcua.miscellaneous", "modules/opcua.server", "modules/opcua.server.simulation", "modules/opcua.status-code", "modules/opcua.transport", "modules/opcua.utils", "modules/opcua.variant", "modules/service.filter.tools", "modules/services.browse", "modules/services.call", "modules/services.discovery", "modules/services.endpoints", "modules/services.filter", "modules/services.history", "modules/services.node_management", "modules/services.query", "modules/services.read", "modules/services.register-server", "modules/services.register_node", "modules/services.secure-channel", "modules/services.session", "modules/services.subscription", "modules/services.translate-browse-path", "modules/services.write", "modules/StatusCodes", "modules/xml2json"]'>
        </form>
    </div>
</div>
<div class="container">

<div class="row">
<script type="text/javascript" src="http://www.google.com/cse/query_renderer.js"></script>
<div id="queries"></div>
<script src="http://www.google.com/cse/api/partner-pub-8886208393040088/cse/1374394727/queries/js?oe=UTF-8&amp;callback=(new+PopularQueryRenderer(document.getElementById(%22queries%22))).render"></script>

</div>

    <div class="row">
        <div class="span3">

            <!-- Ad by Google -->
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-format="fluid"
                 data-ad-layout-key="-8h+1u-de+eo+dy"
                 data-ad-client="ca-pub-8886208393040088"
                 data-ad-slot="9362364253"></ins>
            <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
            </script>
            <!-- -->

	         <div>
	             <h3>APIs</h3>
	             <div id="sidebar">
	                 <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                     <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                     <li><a href="#modules" data-toggle="tab">Modules</a></li>
	                 </ul>
	         
	                 <div id="api-tabview-filter">
	                     <input type="search" placeholder="Type to filter APIs">
	                 </div>
	         
	                 <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                     <div class="tab-pane active" id="classes">
	                         <ul id="api-classes" class="nav nav-list">
	                                 <li><a href="../classes/AcknowledgeMessage.html">AcknowledgeMessage</a></li>
	                                 <li><a href="../classes/ActivateSessionRequest.html">ActivateSessionRequest</a></li>
	                                 <li><a href="../classes/ActivateSessionResponse.html">ActivateSessionResponse</a></li>
	                                 <li><a href="../classes/AddNodesItem.html">AddNodesItem</a></li>
	                                 <li><a href="../classes/AddNodesRequest.html">AddNodesRequest</a></li>
	                                 <li><a href="../classes/AddNodesResponse.html">AddNodesResponse</a></li>
	                                 <li><a href="../classes/AddNodesResult.html">AddNodesResult</a></li>
	                                 <li><a href="../classes/AddReferencesItem.html">AddReferencesItem</a></li>
	                                 <li><a href="../classes/AddReferencesRequest.html">AddReferencesRequest</a></li>
	                                 <li><a href="../classes/AddReferencesResponse.html">AddReferencesResponse</a></li>
	                                 <li><a href="../classes/AddressSpace.html">AddressSpace</a></li>
	                                 <li><a href="../classes/AggregateConfiguration.html">AggregateConfiguration</a></li>
	                                 <li><a href="../classes/AggregateFilter.html">AggregateFilter</a></li>
	                                 <li><a href="../classes/AnonymousIdentityToken.html">AnonymousIdentityToken</a></li>
	                                 <li><a href="../classes/ApplicationDescription.html">ApplicationDescription</a></li>
	                                 <li><a href="../classes/ApplicationInstanceCertificate.html">ApplicationInstanceCertificate</a></li>
	                                 <li><a href="../classes/Argument.html">Argument</a></li>
	                                 <li><a href="../classes/AsymmetricAlgorithmSecurityHeader.html">AsymmetricAlgorithmSecurityHeader</a></li>
	                                 <li><a href="../classes/AttributeIds.html">AttributeIds</a></li>
	                                 <li><a href="../classes/AttributeNameById.html">AttributeNameById</a></li>
	                                 <li><a href="../classes/AttributeOperand.html">AttributeOperand</a></li>
	                                 <li><a href="../classes/AxisInformation.html">AxisInformation</a></li>
	                                 <li><a href="../classes/BaseEventType.html">BaseEventType</a></li>
	                                 <li><a href="../classes/BaseNode.html">BaseNode</a></li>
	                                 <li><a href="../classes/BaseUAObject.html">BaseUAObject</a></li>
	                                 <li><a href="../classes/BinaryStream.html">BinaryStream</a></li>
	                                 <li><a href="../classes/BinaryStreamSizeCalculator.html">BinaryStreamSizeCalculator</a></li>
	                                 <li><a href="../classes/BrowseDescription.html">BrowseDescription</a></li>
	                                 <li><a href="../classes/BrowseDirection.html">BrowseDirection</a></li>
	                                 <li><a href="../classes/BrowseNextRequest.html">BrowseNextRequest</a></li>
	                                 <li><a href="../classes/BrowseNextResponse.html">BrowseNextResponse</a></li>
	                                 <li><a href="../classes/BrowsePath.html">BrowsePath</a></li>
	                                 <li><a href="../classes/BrowsePathResult.html">BrowsePathResult</a></li>
	                                 <li><a href="../classes/BrowsePathTarget.html">BrowsePathTarget</a></li>
	                                 <li><a href="../classes/BrowseRequest.html">BrowseRequest</a></li>
	                                 <li><a href="../classes/BrowseResponse.html">BrowseResponse</a></li>
	                                 <li><a href="../classes/BrowseResult.html">BrowseResult</a></li>
	                                 <li><a href="../classes/BuildInfo.html">BuildInfo</a></li>
	                                 <li><a href="../classes/CallMethodRequest.html">CallMethodRequest</a></li>
	                                 <li><a href="../classes/CallMethodResult.html">CallMethodResult</a></li>
	                                 <li><a href="../classes/CallRequest.html">CallRequest</a></li>
	                                 <li><a href="../classes/CallResponse.html">CallResponse</a></li>
	                                 <li><a href="../classes/CancelRequest.html">CancelRequest</a></li>
	                                 <li><a href="../classes/CancelResponse.html">CancelResponse</a></li>
	                                 <li><a href="../classes/ChannelSecurityToken.html">ChannelSecurityToken</a></li>
	                                 <li><a href="../classes/ChunkManager.html">ChunkManager</a></li>
	                                 <li><a href="../classes/ClientMonitoredItem.html">ClientMonitoredItem</a></li>
	                                 <li><a href="../classes/ClientMonitoredItemGroup.html">ClientMonitoredItemGroup</a></li>
	                                 <li><a href="../classes/ClientSecureChannelLayer.html">ClientSecureChannelLayer</a></li>
	                                 <li><a href="../classes/ClientSession.html">ClientSession</a></li>
	                                 <li><a href="../classes/ClientSidePublishEngine.html">ClientSidePublishEngine</a></li>
	                                 <li><a href="../classes/ClientSubscription.html">ClientSubscription</a></li>
	                                 <li><a href="../classes/ClientTCP_transport.html">ClientTCP_transport</a></li>
	                                 <li><a href="../classes/CloseSecureChannelRequest.html">CloseSecureChannelRequest</a></li>
	                                 <li><a href="../classes/CloseSecureChannelResponse.html">CloseSecureChannelResponse</a></li>
	                                 <li><a href="../classes/CloseSessionRequest.html">CloseSessionRequest</a></li>
	                                 <li><a href="../classes/CloseSessionResponse.html">CloseSessionResponse</a></li>
	                                 <li><a href="../classes/ConditionInfo.html">ConditionInfo</a></li>
	                                 <li><a href="../classes/ContentFilter.html">ContentFilter</a></li>
	                                 <li><a href="../classes/ContentFilterElement.html">ContentFilterElement</a></li>
	                                 <li><a href="../classes/ContentFilterElementResult.html">ContentFilterElementResult</a></li>
	                                 <li><a href="../classes/ContentFilterResult.html">ContentFilterResult</a></li>
	                                 <li><a href="../classes/CreateMonitoredItemsRequest.html">CreateMonitoredItemsRequest</a></li>
	                                 <li><a href="../classes/CreateMonitoredItemsResponse.html">CreateMonitoredItemsResponse</a></li>
	                                 <li><a href="../classes/CreateSessionRequest.html">CreateSessionRequest</a></li>
	                                 <li><a href="../classes/CreateSessionResponse.html">CreateSessionResponse</a></li>
	                                 <li><a href="../classes/CreateSubscriptionRequest.html">CreateSubscriptionRequest</a></li>
	                                 <li><a href="../classes/CreateSubscriptionResponse.html">CreateSubscriptionResponse</a></li>
	                                 <li><a href="../classes/DataChangeFilter.html">DataChangeFilter</a></li>
	                                 <li><a href="../classes/DataChangeNotification.html">DataChangeNotification</a></li>
	                                 <li><a href="../classes/DataValue.html">DataValue</a></li>
	                                 <li><a href="../classes/DeleteMonitoredItemsRequest.html">DeleteMonitoredItemsRequest</a></li>
	                                 <li><a href="../classes/DeleteMonitoredItemsResponse.html">DeleteMonitoredItemsResponse</a></li>
	                                 <li><a href="../classes/DeleteNodesItem.html">DeleteNodesItem</a></li>
	                                 <li><a href="../classes/DeleteNodesRequest.html">DeleteNodesRequest</a></li>
	                                 <li><a href="../classes/DeleteNodesResponse.html">DeleteNodesResponse</a></li>
	                                 <li><a href="../classes/DeleteReferencesItem.html">DeleteReferencesItem</a></li>
	                                 <li><a href="../classes/DeleteReferencesRequest.html">DeleteReferencesRequest</a></li>
	                                 <li><a href="../classes/DeleteReferencesResponse.html">DeleteReferencesResponse</a></li>
	                                 <li><a href="../classes/DeleteSubscriptionsRequest.html">DeleteSubscriptionsRequest</a></li>
	                                 <li><a href="../classes/DeleteSubscriptionsResponse.html">DeleteSubscriptionsResponse</a></li>
	                                 <li><a href="../classes/DiagnosticInfo.html">DiagnosticInfo</a></li>
	                                 <li><a href="../classes/ElementOperand.html">ElementOperand</a></li>
	                                 <li><a href="../classes/EndpointDescription.html">EndpointDescription</a></li>
	                                 <li><a href="../classes/Enum.html">Enum</a></li>
	                                 <li><a href="../classes/EnumValueType.html">EnumValueType</a></li>
	                                 <li><a href="../classes/ErrorMessage.html">ErrorMessage</a></li>
	                                 <li><a href="../classes/EUInformation.html">EUInformation</a></li>
	                                 <li><a href="../classes/EventData.html">EventData</a></li>
	                                 <li><a href="../classes/EventFieldList.html">EventFieldList</a></li>
	                                 <li><a href="../classes/EventFilter.html">EventFilter</a></li>
	                                 <li><a href="../classes/EventFilterResult.html">EventFilterResult</a></li>
	                                 <li><a href="../classes/EventNotificationList.html">EventNotificationList</a></li>
	                                 <li><a href="../classes/ExpandedNodeId.html">ExpandedNodeId</a></li>
	                                 <li><a href="../classes/Factory.html">Factory</a></li>
	                                 <li><a href="../classes/FilterOperand.html">FilterOperand</a></li>
	                                 <li><a href="../classes/FindServersOnNetworkRequest.html">FindServersOnNetworkRequest</a></li>
	                                 <li><a href="../classes/FindServersOnNetworkResponse.html">FindServersOnNetworkResponse</a></li>
	                                 <li><a href="../classes/FindServersRequest.html">FindServersRequest</a></li>
	                                 <li><a href="../classes/FindServersResponse.html">FindServersResponse</a></li>
	                                 <li><a href="../classes/GetEndpointsRequest.html">GetEndpointsRequest</a></li>
	                                 <li><a href="../classes/GetEndpointsResponse.html">GetEndpointsResponse</a></li>
	                                 <li><a href="../classes/HelloMessage.html">HelloMessage</a></li>
	                                 <li><a href="../classes/HistoryData.html">HistoryData</a></li>
	                                 <li><a href="../classes/HistoryModifiedData.html">HistoryModifiedData</a></li>
	                                 <li><a href="../classes/HistoryReadDetails.html">HistoryReadDetails</a></li>
	                                 <li><a href="../classes/HistoryReadRequest.html">HistoryReadRequest</a></li>
	                                 <li><a href="../classes/HistoryReadResponse.html">HistoryReadResponse</a></li>
	                                 <li><a href="../classes/HistoryReadResult.html">HistoryReadResult</a></li>
	                                 <li><a href="../classes/HistoryReadValueId.html">HistoryReadValueId</a></li>
	                                 <li><a href="../classes/HistoryServerCapabilities.html">HistoryServerCapabilities</a></li>
	                                 <li><a href="../classes/HistoryUpdateRequest.html">HistoryUpdateRequest</a></li>
	                                 <li><a href="../classes/HistoryUpdateResponse.html">HistoryUpdateResponse</a></li>
	                                 <li><a href="../classes/HistoryUpdateResult.html">HistoryUpdateResult</a></li>
	                                 <li><a href="../classes/IssuedIdentityToken.html">IssuedIdentityToken</a></li>
	                                 <li><a href="../classes/LiteralOperand.html">LiteralOperand</a></li>
	                                 <li><a href="../classes/LocalizedText.html">LocalizedText</a></li>
	                                 <li><a href="../classes/MdnsDiscoveryConfiguration.html">MdnsDiscoveryConfiguration</a></li>
	                                 <li><a href="../classes/MessageBuilder.html">MessageBuilder</a></li>
	                                 <li><a href="../classes/MessageBuilderBase.html">MessageBuilderBase</a></li>
	                                 <li><a href="../classes/MessageChunker.html">MessageChunker</a></li>
	                                 <li><a href="../classes/ModelChangeStructure.html">ModelChangeStructure</a></li>
	                                 <li><a href="../classes/ModificationInfo.html">ModificationInfo</a></li>
	                                 <li><a href="../classes/ModifyMonitoredItemsRequest.html">ModifyMonitoredItemsRequest</a></li>
	                                 <li><a href="../classes/ModifyMonitoredItemsResponse.html">ModifyMonitoredItemsResponse</a></li>
	                                 <li><a href="../classes/ModifySubscriptionRequest.html">ModifySubscriptionRequest</a></li>
	                                 <li><a href="../classes/ModifySubscriptionResponse.html">ModifySubscriptionResponse</a></li>
	                                 <li><a href="../classes/MonitoredItem.html">MonitoredItem</a></li>
	                                 <li><a href="../classes/MonitoredItemCreateRequest.html">MonitoredItemCreateRequest</a></li>
	                                 <li><a href="../classes/MonitoredItemCreateResult.html">MonitoredItemCreateResult</a></li>
	                                 <li><a href="../classes/MonitoredItemModifyRequest.html">MonitoredItemModifyRequest</a></li>
	                                 <li><a href="../classes/MonitoredItemModifyResult.html">MonitoredItemModifyResult</a></li>
	                                 <li><a href="../classes/MonitoredItemNotification.html">MonitoredItemNotification</a></li>
	                                 <li><a href="../classes/MonitoringFilter.html">MonitoringFilter</a></li>
	                                 <li><a href="../classes/MonitoringParameters.html">MonitoringParameters</a></li>
	                                 <li><a href="../classes/NodeCrawler.html">NodeCrawler</a></li>
	                                 <li><a href="../classes/NodeId.html">NodeId</a></li>
	                                 <li><a href="../classes/NodeIdType.html">NodeIdType</a></li>
	                                 <li><a href="../classes/NodeTypeDescription.html">NodeTypeDescription</a></li>
	                                 <li><a href="../classes/NotificationMessage.html">NotificationMessage</a></li>
	                                 <li><a href="../classes/opcua.html">opcua</a></li>
	                                 <li><a href="../classes/OPCUABaseServer.html">OPCUABaseServer</a></li>
	                                 <li><a href="../classes/OPCUAClient.html">OPCUAClient</a></li>
	                                 <li><a href="../classes/OPCUAClientBase.html">OPCUAClientBase</a></li>
	                                 <li><a href="../classes/OPCUASecureObject.html">OPCUASecureObject</a></li>
	                                 <li><a href="../classes/OPCUAServer.html">OPCUAServer</a></li>
	                                 <li><a href="../classes/OPCUAServerEndPoint.html">OPCUAServerEndPoint</a></li>
	                                 <li><a href="../classes/OpenSecureChannelRequest.html">OpenSecureChannelRequest</a></li>
	                                 <li><a href="../classes/OpenSecureChannelResponse.html">OpenSecureChannelResponse</a></li>
	                                 <li><a href="../classes/OperationLimits.html">OperationLimits</a></li>
	                                 <li><a href="../classes/PacketAssembler.html">PacketAssembler</a></li>
	                                 <li><a href="../classes/ParsingResult.html">ParsingResult</a></li>
	                                 <li><a href="../classes/PublishRequest.html">PublishRequest</a></li>
	                                 <li><a href="../classes/PublishResponse.html">PublishResponse</a></li>
	                                 <li><a href="../classes/QualifiedName.html">QualifiedName</a></li>
	                                 <li><a href="../classes/QueryDataDescription.html">QueryDataDescription</a></li>
	                                 <li><a href="../classes/QueryDataSet.html">QueryDataSet</a></li>
	                                 <li><a href="../classes/QueryFirstRequest.html">QueryFirstRequest</a></li>
	                                 <li><a href="../classes/QueryFirstResponse.html">QueryFirstResponse</a></li>
	                                 <li><a href="../classes/QueryNextRequest.html">QueryNextRequest</a></li>
	                                 <li><a href="../classes/QueryNextResponse.html">QueryNextResponse</a></li>
	                                 <li><a href="../classes/Range.html">Range</a></li>
	                                 <li><a href="../classes/ReadAtTimeDetails.html">ReadAtTimeDetails</a></li>
	                                 <li><a href="../classes/ReadEventDetails.html">ReadEventDetails</a></li>
	                                 <li><a href="../classes/ReadProcessedDetails.html">ReadProcessedDetails</a></li>
	                                 <li><a href="../classes/ReadRawModifiedDetails.html">ReadRawModifiedDetails</a></li>
	                                 <li><a href="../classes/ReadRequest.html">ReadRequest</a></li>
	                                 <li><a href="../classes/ReadResponse.html">ReadResponse</a></li>
	                                 <li><a href="../classes/ReadValueId.html">ReadValueId</a></li>
	                                 <li><a href="../classes/RedundantServer.html">RedundantServer</a></li>
	                                 <li><a href="../classes/Reference.html">Reference</a></li>
	                                 <li><a href="../classes/ReferenceDescription.html">ReferenceDescription</a></li>
	                                 <li><a href="../classes/ReferenceType.html">ReferenceType</a></li>
	                                 <li><a href="../classes/RegisteredServer.html">RegisteredServer</a></li>
	                                 <li><a href="../classes/RegisterNodesRequest.html">RegisterNodesRequest</a></li>
	                                 <li><a href="../classes/RegisterNodesResponse.html">RegisterNodesResponse</a></li>
	                                 <li><a href="../classes/RegisterServer2Request.html">RegisterServer2Request</a></li>
	                                 <li><a href="../classes/RegisterServer2Response.html">RegisterServer2Response</a></li>
	                                 <li><a href="../classes/RegisterServerRequest.html">RegisterServerRequest</a></li>
	                                 <li><a href="../classes/RegisterServerResponse.html">RegisterServerResponse</a></li>
	                                 <li><a href="../classes/RelativePath.html">RelativePath</a></li>
	                                 <li><a href="../classes/RelativePathElement.html">RelativePathElement</a></li>
	                                 <li><a href="../classes/RepublishRequest.html">RepublishRequest</a></li>
	                                 <li><a href="../classes/RepublishResponse.html">RepublishResponse</a></li>
	                                 <li><a href="../classes/RequestHeader.html">RequestHeader</a></li>
	                                 <li><a href="../classes/ResponseHeader.html">ResponseHeader</a></li>
	                                 <li><a href="../classes/SamplingIntervalDiagnostics.html">SamplingIntervalDiagnostics</a></li>
	                                 <li><a href="../classes/SecureMessageChunkManager.html">SecureMessageChunkManager</a></li>
	                                 <li><a href="../classes/SecurityPolicy.html">SecurityPolicy</a></li>
	                                 <li><a href="../classes/SemanticChangeStructure.html">SemanticChangeStructure</a></li>
	                                 <li><a href="../classes/SequenceHeader.html">SequenceHeader</a></li>
	                                 <li><a href="../classes/SequenceNumberGenerator.html">SequenceNumberGenerator</a></li>
	                                 <li><a href="../classes/ServerCapabilities.html">ServerCapabilities</a></li>
	                                 <li><a href="../classes/ServerDiagnosticsSummary.html">ServerDiagnosticsSummary</a></li>
	                                 <li><a href="../classes/ServerEngine.html">ServerEngine</a></li>
	                                 <li><a href="../classes/ServerOnNetwork.html">ServerOnNetwork</a></li>
	                                 <li><a href="../classes/ServerSecureChannelLayer.html">ServerSecureChannelLayer</a></li>
	                                 <li><a href="../classes/ServerSidePublishEngine.html">ServerSidePublishEngine</a></li>
	                                 <li><a href="../classes/ServerStatus.html">ServerStatus</a></li>
	                                 <li><a href="../classes/ServerTCP_transport.html">ServerTCP_transport</a></li>
	                                 <li><a href="../classes/ServiceCounter.html">ServiceCounter</a></li>
	                                 <li><a href="../classes/ServiceFault.html">ServiceFault</a></li>
	                                 <li><a href="../classes/SessionContext.html">SessionContext</a></li>
	                                 <li><a href="../classes/SessionDiagnostics.html">SessionDiagnostics</a></li>
	                                 <li><a href="../classes/SessionSecurityDiagnostics.html">SessionSecurityDiagnostics</a></li>
	                                 <li><a href="../classes/SetMonitoringModeRequest.html">SetMonitoringModeRequest</a></li>
	                                 <li><a href="../classes/SetMonitoringModeResponse.html">SetMonitoringModeResponse</a></li>
	                                 <li><a href="../classes/SetPublishingModeRequest.html">SetPublishingModeRequest</a></li>
	                                 <li><a href="../classes/SetPublishingModeResponse.html">SetPublishingModeResponse</a></li>
	                                 <li><a href="../classes/SetTriggeringRequest.html">SetTriggeringRequest</a></li>
	                                 <li><a href="../classes/SetTriggeringResponse.html">SetTriggeringResponse</a></li>
	                                 <li><a href="../classes/SignatureData.html">SignatureData</a></li>
	                                 <li><a href="../classes/SignedSoftwareCertificate.html">SignedSoftwareCertificate</a></li>
	                                 <li><a href="../classes/SimpleAttributeOperand.html">SimpleAttributeOperand</a></li>
	                                 <li><a href="../classes/Simulator.html">Simulator</a></li>
	                                 <li><a href="../classes/StatusChangeNotification.html">StatusChangeNotification</a></li>
	                                 <li><a href="../classes/StatusCode.html">StatusCode</a></li>
	                                 <li><a href="../classes/Subscription.html">Subscription</a></li>
	                                 <li><a href="../classes/SubscriptionAcknowledgement.html">SubscriptionAcknowledgement</a></li>
	                                 <li><a href="../classes/SubscriptionDiagnostics.html">SubscriptionDiagnostics</a></li>
	                                 <li><a href="../classes/SymmetricAlgorithmSecurityHeader.html">SymmetricAlgorithmSecurityHeader</a></li>
	                                 <li><a href="../classes/TCP_transport.html">TCP_transport</a></li>
	                                 <li><a href="../classes/TCPErrorMessage.html">TCPErrorMessage</a></li>
	                                 <li><a href="../classes/TimestampsToReturn.html">TimestampsToReturn</a></li>
	                                 <li><a href="../classes/TimeZone.html">TimeZone</a></li>
	                                 <li><a href="../classes/ToolBrowsePath.html">ToolBrowsePath</a></li>
	                                 <li><a href="../classes/TransferResult.html">TransferResult</a></li>
	                                 <li><a href="../classes/TransferSubscriptionsRequest.html">TransferSubscriptionsRequest</a></li>
	                                 <li><a href="../classes/TransferSubscriptionsResponse.html">TransferSubscriptionsResponse</a></li>
	                                 <li><a href="../classes/TranslateBrowsePathsToNodeIdsRequest.html">TranslateBrowsePathsToNodeIdsRequest</a></li>
	                                 <li><a href="../classes/TranslateBrowsePathsToNodeIdsResponse.html">TranslateBrowsePathsToNodeIdsResponse</a></li>
	                                 <li><a href="../classes/TypeSchema.html">TypeSchema</a></li>
	                                 <li><a href="../classes/UAAcknowledgeableConditionBase.html">UAAcknowledgeableConditionBase</a></li>
	                                 <li><a href="../classes/UAAlarmConditionBase.html">UAAlarmConditionBase</a></li>
	                                 <li><a href="../classes/UACertificateExpirationAlarm.html">UACertificateExpirationAlarm</a></li>
	                                 <li><a href="../classes/UAConditionBase.html">UAConditionBase</a></li>
	                                 <li><a href="../classes/UADataType.html">UADataType</a></li>
	                                 <li><a href="../classes/UADiscreteAlarm.html">UADiscreteAlarm</a></li>
	                                 <li><a href="../classes/UAExclusiveDeviationAlarm.html">UAExclusiveDeviationAlarm</a></li>
	                                 <li><a href="../classes/UAExclusiveLevelAlarm.html">UAExclusiveLevelAlarm</a></li>
	                                 <li><a href="../classes/UAExclusiveLimitAlarm.html">UAExclusiveLimitAlarm</a></li>
	                                 <li><a href="../classes/UAExclusiveRateOfChangeAlarm.html">UAExclusiveRateOfChangeAlarm</a></li>
	                                 <li><a href="../classes/UALimitAlarm.html">UALimitAlarm</a></li>
	                                 <li><a href="../classes/UAMultiStateDiscreteType.html">UAMultiStateDiscreteType</a></li>
	                                 <li><a href="../classes/UANonExclusiveDeviationAlarm.html">UANonExclusiveDeviationAlarm</a></li>
	                                 <li><a href="../classes/UANonExclusiveLimitAlarm.html">UANonExclusiveLimitAlarm</a></li>
	                                 <li><a href="../classes/UAObject.html">UAObject</a></li>
	                                 <li><a href="../classes/UAObjectType.html">UAObjectType</a></li>
	                                 <li><a href="../classes/UAOffNormalAlarm.html">UAOffNormalAlarm</a></li>
	                                 <li><a href="../classes/UAProxyManager.html">UAProxyManager</a></li>
	                                 <li><a href="../classes/UASystemOffNormalAlarm.html">UASystemOffNormalAlarm</a></li>
	                                 <li><a href="../classes/UATripAlarm.html">UATripAlarm</a></li>
	                                 <li><a href="../classes/UATwoStateVariable.html">UATwoStateVariable</a></li>
	                                 <li><a href="../classes/UAVariable.html">UAVariable</a></li>
	                                 <li><a href="../classes/UAVariableType.html">UAVariableType</a></li>
	                                 <li><a href="../classes/UnregisterNodesRequest.html">UnregisterNodesRequest</a></li>
	                                 <li><a href="../classes/UnregisterNodesResponse.html">UnregisterNodesResponse</a></li>
	                                 <li><a href="../classes/UserNameIdentityToken.html">UserNameIdentityToken</a></li>
	                                 <li><a href="../classes/UserTokenPolicy.html">UserTokenPolicy</a></li>
	                                 <li><a href="../classes/Variant.html">Variant</a></li>
	                                 <li><a href="../classes/View.html">View</a></li>
	                                 <li><a href="../classes/ViewDescription.html">ViewDescription</a></li>
	                                 <li><a href="../classes/WriteRequest.html">WriteRequest</a></li>
	                                 <li><a href="../classes/WriteResponse.html">WriteResponse</a></li>
	                                 <li><a href="../classes/WriteValue.html">WriteValue</a></li>
	                                 <li><a href="../classes/X509IdentityToken.html">X509IdentityToken</a></li>
	                                 <li><a href="../classes/Xml2Json.html">Xml2Json</a></li>
	                         </ul>
	                     </div>
	         
	                     <div class="tab-pane" id="modules">
	                         <ul id="api-modules" class="nav nav-list">
	                                 <li><a href="../modules/opcua.address_space.html">opcua.address_space</a></li>
	                                 <li><a href="../modules/opcua.address_space.AlarmsAndConditions.html">opcua.address_space.AlarmsAndConditions</a></li>
	                                 <li><a href="../modules/opcua.address_space.types.html">opcua.address_space.types</a></li>
	                                 <li><a href="../modules/opcua.client.html">opcua.client</a></li>
	                                 <li><a href="../modules/opcua.data-value.html">opcua.data-value</a></li>
	                                 <li><a href="../modules/opcua.datamodel.html">opcua.datamodel</a></li>
	                                 <li><a href="../modules/opcua.miscellaneous.html">opcua.miscellaneous</a></li>
	                                 <li><a href="../modules/opcua.server.html">opcua.server</a></li>
	                                 <li><a href="../modules/opcua.server.simulation.html">opcua.server.simulation</a></li>
	                                 <li><a href="../modules/opcua.status-code.html">opcua.status-code</a></li>
	                                 <li><a href="../modules/opcua.transport.html">opcua.transport</a></li>
	                                 <li><a href="../modules/opcua.utils.html">opcua.utils</a></li>
	                                 <li><a href="../modules/opcua.variant.html">opcua.variant</a></li>
	                                 <li><a href="../modules/service.filter.tools.html">service.filter.tools</a></li>
	                                 <li><a href="../modules/services.browse.html">services.browse</a></li>
	                                 <li><a href="../modules/services.call.html">services.call</a></li>
	                                 <li><a href="../modules/services.discovery.html">services.discovery</a></li>
	                                 <li><a href="../modules/services.endpoints.html">services.endpoints</a></li>
	                                 <li><a href="../modules/services.filter.html">services.filter</a></li>
	                                 <li><a href="../modules/services.history.html">services.history</a></li>
	                                 <li><a href="../modules/services.node_management.html">services.node_management</a></li>
	                                 <li><a href="../modules/services.query.html">services.query</a></li>
	                                 <li><a href="../modules/services.read.html">services.read</a></li>
	                                 <li><a href="../modules/services.register-server.html">services.register-server</a></li>
	                                 <li><a href="../modules/services.register_node.html">services.register_node</a></li>
	                                 <li><a href="../modules/services.secure-channel.html">services.secure-channel</a></li>
	                                 <li><a href="../modules/services.session.html">services.session</a></li>
	                                 <li><a href="../modules/services.subscription.html">services.subscription</a></li>
	                                 <li><a href="../modules/services.translate-browse-path.html">services.translate-browse-path</a></li>
	                                 <li><a href="../modules/services.write.html">services.write</a></li>
	                                 <li><a href="../modules/StatusCodes.html">StatusCodes</a></li>
	                                 <li><a href="../modules/xml2json.html">xml2json</a></li>
	                         </ul>
	                     </div>
	                 </div>
	             </div>
	         </div>
	    
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>packages\node-opcua-address-space\src\base_node.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
&quot;use strict&quot;;

/*jslint bitwise: true */
/**
 * @module opcua.address_space
 */

require(&quot;object.values&quot;);
const util = require(&quot;util&quot;);
const utils = require(&quot;node-opcua-utils&quot;);

const EventEmitter = require(&quot;events&quot;).EventEmitter;

const NodeId = require(&quot;node-opcua-nodeid&quot;).NodeId;
const makeNodeId = require(&quot;node-opcua-nodeid&quot;).makeNodeId;
const resolveNodeId = require(&quot;node-opcua-nodeid&quot;).resolveNodeId;
const sameNodeId = require(&quot;node-opcua-nodeid&quot;).sameNodeId;

const coerceQualifyName = require(&quot;node-opcua-data-model&quot;).coerceQualifyName;
const QualifiedName = require(&quot;node-opcua-data-model&quot;).QualifiedName;
const coerceLocalizedText = require(&quot;node-opcua-data-model&quot;).coerceLocalizedText;
const AttributeNameById = require(&quot;node-opcua-data-model&quot;).AttributeNameById;
const ResultMask = require(&quot;node-opcua-data-model&quot;).ResultMask;
const NodeClass = require(&quot;node-opcua-data-model&quot;).NodeClass;
const makeNodeClassMask = require(&quot;node-opcua-data-model&quot;).makeNodeClassMask;
const AttributeIds = require(&quot;node-opcua-data-model&quot;).AttributeIds;
const BrowseDirection = require(&quot;node-opcua-data-model&quot;).BrowseDirection;
const ReferenceDescription = require(&quot;node-opcua-service-browse&quot;).ReferenceDescription;

const DataValue = require(&quot;node-opcua-data-value&quot;).DataValue;

const DataType = require(&quot;node-opcua-variant&quot;).DataType;

const StatusCodes = require(&quot;node-opcua-status-code&quot;).StatusCodes;


exports.BrowseDirection = BrowseDirection;

const assert = require(&quot;node-opcua-assert&quot;).assert;
const _ = require(&quot;underscore&quot;);
const dumpIf = require(&quot;node-opcua-debug&quot;).dumpIf;
let ReferenceType = null;// will be defined after baseNode is defined

const lowerFirstLetter = require(&quot;node-opcua-utils&quot;).lowerFirstLetter;
const capitalizeFirstLetter = require(&quot;node-opcua-utils&quot;).capitalizeFirstLetter;

const doDebug = false;

const SessionContext = require(&quot;./session_context&quot;).SessionContext;
const Reference = require(&quot;./reference&quot;).Reference;


function defaultBrowseFilterFunc(session) {

    return true;
}

function _get_QualifiedBrowseName(browseName) {
    return coerceQualifyName(browseName);
}

/**
 * Base class for all address_space classes
 *
 * BaseNode is the base class for all the OPCUA objects in the address space
 * It provides attributes and a set of references to other nodes.
 * see:
 * {{#crossLink &quot;UAObject&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UAVariable&quot;}}{{/crossLink}},
 * {{#crossLink &quot;Reference&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UAMethod&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UAView&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UAObjecType&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UADataType&quot;}}{{/crossLink}},
 * {{#crossLink &quot;UAVariableType&quot;}}{{/crossLink}},
 *
 * @class BaseNode
 * @constructor
 *
 * @param options
 * @param options.addressSpace {AddressSpace}
 * @param options.browseName {QualifiedName}
 * @param [options.displayName] {String|LocalizedText}
 * @param options.references {Reference[]}
 * @param [options.description]  {String|LocalizedText}
 * @param [options.browseFilter] {Function}
 *
 *
 *
 *
 */
function BaseNode(options) {

    const self = this;
    const _private = BaseNode_initPrivate(self);

    assert(this.nodeClass);
    assert(options.addressSpace); // expecting an address space
    assert(options.browseName instanceof QualifiedName, &quot;Expecting a valid QualifiedName&quot;);
    assert(options.nodeId instanceof NodeId, &quot;Expecting a valid NodeId&quot;);
    assert(options.addressSpace.constructor.name === &quot;AddressSpace&quot;);
    options.references = options.references || [];

    _private.__address_space = options.addressSpace;

    this.nodeId = resolveNodeId(options.nodeId);

    // QualifiedName
    /**
     * the node browseName
     * @property browseName
     * @type QualifiedName
     * @static
     */
    this.browseName = _get_QualifiedBrowseName(options.browseName);

    // re-use browseName as displayName if displayName is missing
    options.displayName = options.displayName || options.browseName.name.toString();

    this._setDisplayName(options.displayName);


    this._setDescription(options.description);


    //Xx Object.defineProperty(this, &quot;_cache&quot;,             {configurable: true,value:{}, hidden:true,enumerable: false});
    //xx Object.defineProperty(this, &quot;_referenceIdx&quot;,      {configurable: true,value:{}, hidden:true,enumerable: false});
    //xx Object.defineProperty(this, &quot;_back_referenceIdx&quot;, {configurable: true,value:{}, hidden:true,enumerable: false});


    // user defined filter function for browsing
    const _browseFilter = options.browseFilter || defaultBrowseFilterFunc;
    assert(_.isFunction(_browseFilter));
    Object.defineProperty(this, &quot;_browseFilter&quot;, {
        configurable: true,
        value: _browseFilter,
        hidden: true,
        enumerable: false
    });

    // normalize reference type
    // this will convert any referenceType expressed with its inverseName into
    // its normal name and fix the isForward flag accordingly.
    // ( e.g &quot;ComponentOf&quot; isForward:true =&gt; &quot;HasComponent&quot;, isForward:false)
    for (const reference of options.references) {
        self.__addReference(reference);
    }

}

util.inherits(BaseNode, EventEmitter);


const reservedNames = {
    &quot;nodeClass&quot;: 0,
    //Xx &quot;_cache&quot;:0,
    //Xx  &quot;_referenceIdx&quot;:0,
    //Xx  &quot;__back_referenceIdx&quot;:0,
    &quot;__displayName&quot;: 0,
    &quot;displayName&quot;: 0,
    &quot;description&quot;: 0,
    &quot;__description&quot;: 0,
    &quot;typeDefinition&quot;: 0
};

BaseNode.Reference = Reference;


/**
 * @property displayName
 * @type LocalizedText[]
 */
Object.defineProperty(BaseNode.prototype, &quot;__displayName&quot;, {writable: true, hidden: true, enumerable: false});
BaseNode.prototype._setDisplayName = function (displayName) {
    displayName = _.isArray(displayName) ? displayName : [displayName];
    const _displayName = displayName.map(coerceLocalizedText);
    Object.defineProperty(this, &quot;__displayName&quot;, {
        configurable: true,
        value: _displayName,
        hidden: true,
        enumerable: false
    });
};
Object.defineProperty(BaseNode.prototype, &quot;displayName&quot;, {

    get: function () {
        return this.__displayName;
    },
    set: function (value) {
        this._setDisplayName(value);
        /**
         * fires when the displayName is changed.
         * @event DisplayName_changed
         * @param dataValue {DataValue}
         */
        this._notifyAttributeChange(AttributeIds.DisplayName);
    },
    hidden: false,
    enumerable: true
});

BaseNode.prototype.getDisplayName = function (locale) {
    return this.__displayName[0].text;
};

/**
 * @property description
 * @type LocalizedText
 */
Object.defineProperty(BaseNode.prototype, &quot;__description&quot;, {writable: true, hidden: true, enumerable: false});

BaseNode.prototype._setDescription = function (description) {
    const __description = coerceLocalizedText(description);
    Object.defineProperty(this, &quot;__description&quot;, {
        configurable: true,
        value: __description,
        hidden: true,
        enumerable: false
    });
};

Object.defineProperty(BaseNode.prototype, &quot;description&quot;, {

    get: function () {
        return this.__description;
    },
    set: function (value) {
        this._setDescription(value);
        /**
         * fires when the description attribute is changed.
         * @event Description_changed
         * @param dataValue {DataValue}
         */
        this._notifyAttributeChange(AttributeIds.Description);
    },
    hidden: false,
    enumerable: true
});

BaseNode.makeAttributeEventName = function (attributeId) {

    const attributeName = AttributeNameById[attributeId];
    return attributeName + &quot;_changed&quot;;
};


BaseNode.prototype._notifyAttributeChange = function (attributeId) {
    const self = this;
    const event_name = BaseNode.makeAttributeEventName(attributeId);
    self.emit(event_name, self.readAttribute(SessionContext.defaultContext, attributeId));
};


function _is_valid_BrowseDirection(browseDirection) {
    return browseDirection === BrowseDirection.Forward ||
        browseDirection === BrowseDirection.Inverse ||
        browseDirection === BrowseDirection.Both
        ;
}

const g_weakMap = new WeakMap();

function BaseNode_initPrivate(self) {
    assert(self instanceof BaseNode);
    const _private = {
        _referenceIdx: {},
        _back_referenceIdx: {},
        __address_space: null,
        _cache: {}
    };
    g_weakMap.set(self, _private);
    return _private;
}

function BaseNode_getPrivate(self) {
    return g_weakMap.get(self);
}

BaseNode._getCache = function (self) {
    const _private = BaseNode_getPrivate(self);
    return _private._cache;
};


/**
 *
 * @param strReference
 * @param browseDirection
 * @returns {*}
 */
BaseNode.prototype.findReferencesEx = function (strReference, browseDirection) {

    browseDirection = browseDirection || BrowseDirection.Forward;
    assert(_is_valid_BrowseDirection(browseDirection));
    assert(browseDirection !== BrowseDirection.Both);

    let referenceType= null;
    if (typeof strReference === &quot;string&quot;) {
        //xx strReference = strReference.browseName.toString();
        referenceType = this.addressSpace.findReferenceType(strReference);
        if (!referenceType) {
            throw new Error(&quot;Cannot resolve referenceType : &quot;+ strReference);
        }
    } else {
        referenceType = strReference;
    }

    if (!referenceType) {
        // note: when loading nodeset2.xml files, reference type may not exit yet
        // throw new Error(&quot;expecting valid reference name &quot; + strReference);
        return [];
    }

    assert(referenceType instanceof ReferenceType);
    assert(referenceType.nodeId instanceof NodeId);

    const self = this;
    const _private = BaseNode_getPrivate(self);

    const hash = &quot;_refEx_&quot; + referenceType.nodeId.toString() + browseDirection.toString();
    if (_private._cache[hash]) {
        return _private._cache[hash];
    }

    // find a map of all type that derives from the provided reference type
    const keys = referenceType.getSubtypeIndex();

    const isForward = (browseDirection === BrowseDirection.Forward);
    const references = [];

    function process(referenceIdx) {
        const referenceTypes = _.values(referenceIdx);
        for (let ref of referenceTypes) {
            const h = ref.referenceType.toString();
            if ( ref.isForward === isForward &amp;&amp; keys[h] ) {
                assert(ref._referenceType instanceof ReferenceType);
                assert(ref._referenceType.browseName.toString());
                references.push(ref);
            }
        }
    }


    process(_private._referenceIdx);
    process(_private._back_referenceIdx);

    _private._cache[hash] = references;
    return references;
};

BaseNode.prototype.findReferencesExDescription = function (strReference, browseDirection) {

    const refs = this.findReferencesEx(strReference, browseDirection);
    const addressSpace = this.addressSpace;
    const r = refs.map(function (ref) {
        return _makeReferenceDescription(addressSpace, ref, 0x3F);
    });
    return r;
};


BaseNode.prototype._coerceReferenceType = function (referenceType) {

    const self = this;

    if (typeof referenceType === &quot;string&quot;) {
        referenceType = self.addressSpace.findReferenceType(referenceType);
    } else if (referenceType instanceof NodeId) {
        referenceType = self.addressSpace.findNode(referenceType);
    }
    assert(referenceType instanceof ReferenceType);

    return referenceType;
};


/**
 * @method findReferences
 * @param referenceType {String|NodeId|ReferenceType} the referenceType as a string.
 * @param  [isForward=true] {Boolean}
 * @return {Array&lt;Reference&gt;}
 */
BaseNode.prototype.findReferences = function (referenceType, isForward) {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    isForward = utils.isNullOrUndefined(isForward) ? true : !!isForward;
    assert(_.isBoolean(isForward));

    referenceType = this._coerceReferenceType(referenceType);

    const hash = &quot;_ref_&quot; + referenceType.nodeId.toString() + isForward.toString();
    if (_private._cache[hash]) {
        return _private._cache[hash];
    }

    // istanbul ignore next
    if (doDebug &amp;&amp; !(this.addressSpace.findReferenceType(referenceType))) {
        throw new Error(&quot;expecting valid reference name &quot; + referenceType);
    }

    const result = [];
    _.forEach(_private._referenceIdx, function (ref) {
        if (ref.isForward === isForward) {
            if (sameNodeId(ref.referenceType, referenceType.nodeId)) {
                result.push(ref);
            }
        }
    });

    _.forEach(_private._back_referenceIdx, function (ref) {
        if (ref.isForward === isForward) {
            if (sameNodeId(ref.referenceType, referenceType.nodeId)) {
                result.push(ref);
            }
        }
    });

    _private._cache[hash] = result;
    return result;
};


/**
 * @method findReference
 * @param strReference {String} the referenceType as a string.
 * @param [isForward] {Boolean|null}
 * @param [optionalSymbolicName] {String}
 * @return {Reference}
 */
BaseNode.prototype.findReference = function (strReference, isForward, optionalSymbolicName) {

    let refs = this.findReferences(strReference, isForward);

    if (optionalSymbolicName) {
        // search reference that matches symbolic name
        refs = refs.filter(function (ref) {
            return ref.symbolicName === optionalSymbolicName;
        });
    }
    assert(refs.length === 1 || refs.length === 0, &quot;findReference: expecting only one or zero element here&quot;);
    return refs.length === 0 ? null : refs[0];
};


let displayWarning = true;


function toString_ReferenceDescription(ref, options) {

    const addressSpace = options.addressSpace;
    //xx assert(ref instanceof ReferenceDescription);
    const refNode = addressSpace.findNode(ref.referenceTypeId);
    if (!refNode) {
        return &quot;Unknown Ref : &quot; + ref;
    }
    const r = new Reference({
        referenceType: refNode.browseName.toString(),
        nodeId: ref.nodeId,
        isForward: ref.isForward
    });
    const str = r.toString(options);
    r.dispose();
    return str;
}

/* jshint latedef: false */
function _setup_parent_item(references) {

    references = _.map(references);

    /* jshint validthis: true */
    assert(this instanceof BaseNode);
    assert(_.isArray(references));
    const _private = BaseNode_getPrivate(this);

    assert(!_private.parent &amp;&amp; &quot;_setup_parent_item has been already called&quot;);

    const addressSpace = this.addressSpace;

    if (references.length &gt; 0) {

        references = this.findReferencesEx(&quot;HasChild&quot;, BrowseDirection.Inverse);

        if (references.length &gt;= 1) {
            // istanbul ignore next
            if (references.length &gt; 1) {

                if (displayWarning) {

                    const options = {addressSpace: addressSpace};
                    console.warn(&quot;  More than one HasChild reference have been found for parent of object&quot;);
                    console.warn(&quot;    object node id:&quot;, this.nodeId.toString(), this.browseName.toString().cyan);
                    console.warn(&quot;    browseResults:&quot;);
                    console.warn(references.map(function (f) {
                        return toString_ReferenceDescription(f, options);
                    }).join(&quot;\n&quot;));
                    console.warn(&quot;    first one will be used as parent&quot;);
                    //xx assert(browseResults.length === 1);
                    displayWarning = false;
                }
            }
            _private.parent = Reference._resolveReferenceNode(addressSpace, references[0]);
        }
    }
}


function _asObject(nodeIds, addressSpace) {
    function toObject(reference) {
        const obj = _resolveReferenceNode(addressSpace, reference);

        // istanbul ignore next
        if (false &amp;&amp; !obj) {
            console.log(&quot; Warning :  object with nodeId &quot;.red + reference.nodeId.toString().cyan + &quot; cannot be found in the address space !&quot;.red);
        }
        return obj;
    }

    function remove_null(o) {
        return !!o;
    }

    return nodeIds.map(toObject).filter(remove_null);
}

BaseNode.prototype.findReferencesExAsObject = function (strReference, browseDirection) {

    const nodeIds = this.findReferencesEx(strReference, browseDirection);
    const addressSpace = this.addressSpace;
    return _asObject(nodeIds, addressSpace);

};

BaseNode.prototype.findReferencesAsObject = function (strReference, isForward) {

    const nodeIds = this.findReferences(strReference, isForward);
    const addressSpace = this.addressSpace;
    return _asObject(nodeIds, addressSpace);
};


/**
 * returns the nodeId of this node&#x27;s Type Definition
 * @property typeDefinition
 * @type {NodeId}
 */
BaseNode.prototype.__defineGetter__(&quot;typeDefinition&quot;, function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache.typeDefinition) {
        const has_type_definition_ref = this.findReference(&quot;HasTypeDefinition&quot;, true);
        _private._cache.typeDefinition = has_type_definition_ref ? has_type_definition_ref.nodeId : null;
    }
    return _private._cache.typeDefinition;
});


/**
 * returns the nodeId of this node&#x27;s Type Definition
 * @property typeDefinitionObj
 * @type {BaseNode}
 */
BaseNode.prototype.__defineGetter__(&quot;typeDefinitionObj&quot;, function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (undefined === _private._cache.typeDefinitionObj) {
        const nodeId = this.typeDefinition;
        _private._cache.typeDefinitionObj = nodeId ? this.addressSpace.findNode(nodeId) : null;
    }
    return _private._cache.typeDefinitionObj;
});


/**
 * @method getAggregates
 * @return {BaseNode[]} return an array with the Aggregates of this object.
 */
BaseNode.prototype.getAggregates = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._aggregates) {
        _private._cache._aggregates = this.findReferencesExAsObject(&quot;Aggregates&quot;, BrowseDirection.Forward);
    }
    return _private._cache._aggregates;
};

/**
 * @method getComponents
 * @return {BaseNode[]} return an array with the components of this object.
 */
BaseNode.prototype.getComponents = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._components) {
        _private._cache._components = this.findReferencesExAsObject(&quot;HasComponent&quot;, BrowseDirection.Forward);
        //xx_private._cache._components = this.findReferencesAsObject(&quot;HasComponent&quot;, true);
    }
    return _private._cache._components;
};

/**
 * @method getProperties
 * @return {BaseNode[]} return a array with the properties of this object.
 */
BaseNode.prototype.getProperties = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._properties) {
        _private._cache._properties = this.findReferencesExAsObject(&quot;HasProperty&quot;, BrowseDirection.Forward);
    }
    return _private._cache._properties;
};

/**
 * @method getNotifiers
 * @return {BaseNode[]} return a array with the notifiers of this object.
 */
BaseNode.prototype.getNotifiers = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._notifiers) {
        _private._cache._notifiers = this.findReferencesAsObject(&quot;HasNotifier&quot;, true);
    }
    return _private._cache._notifiers;
};

/**
 * @method getEventSources
 * @return {BaseNode[]} return a array with the event source of this object.
 */
BaseNode.prototype.getEventSources = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._eventSources) {
        _private._cache._eventSources = this.findReferencesAsObject(&quot;HasEventSource&quot;, true);
    }
    return _private._cache._eventSources;
};

/**
 * @method getEventSourceOfs
 * @return {BaseNode[]} return a array of the objects for which this node is an EventSource
 */
BaseNode.prototype.getEventSourceOfs = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._eventSources) {
        _private._cache._eventSources = this.findReferencesAsObject(&quot;HasEventSource&quot;, false);
    }
    return _private._cache._eventSources;
};


/**
 * retrieve a component by name
 * @method getComponentByName
 * @param browseName
 * @param [namespaceIndex=null]
 * @return {BaseNode|null}
 */
BaseNode.prototype.getComponentByName = function (browseName, namespaceIndex) {
    assert(typeof browseName === &quot;string&quot;);
    const components = this.getComponents();
    const select = _filter_by_browse_name(components, browseName, namespaceIndex);
    assert(select.length &lt;= 1, &quot;BaseNode#getComponentByName found duplicated reference&quot;);
    return select.length === 1 ? select[0] : null;
};
/**
 * retrieve a property by name
 * @method getPropertyByName
 * @param browseName
 * @param [namespaceIndex=null]
 * @return {BaseNode|null}
 */
BaseNode.prototype.getPropertyByName = function (browseName, namespaceIndex) {
    assert(typeof browseName === &quot;string&quot;);
    const properties = this.getProperties();
    const select = _filter_by_browse_name(properties, browseName, namespaceIndex);
    assert(select.length &lt;= 1, &quot;BaseNode#getPropertyByName found duplicated reference&quot;);
    return select.length === 1 ? select[0] : null;
};

/**
 * retrieve a folder by name
 * @method getPropertyByName
 * @param browseName
 * @param [namespaceIndex=null]
 * @return {BaseNode|null}
 */
BaseNode.prototype.getFolderElementByName = function (browseName, namespaceIndex) {
    assert(typeof browseName === &quot;string&quot;);
    const elements = this.getFolderElements();
    const select = _filter_by_browse_name(elements, browseName, namespaceIndex);
    return select.length === 1 ? select[0] : null;
};

/**
 * returns the list of nodes that this folder object organizes
 * @method getFolderElements
 * @return {Array&lt;UAObject&gt;}
 *
 */
BaseNode.prototype.getFolderElements = function () {
    return this.findReferencesAsObject(&quot;Organizes&quot;, true);
};

/**
 * returns the list of methods that this object provides
 * @method getMethods
 * @return {Array&lt;UAObject&gt;} returns an array wit&quot;h Method objects.
 *
 *
 * Note: internally, methods are special types of components
 */
BaseNode.prototype.getMethods = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._methods) {
        const components = this.getComponents();
        const UAMethod = require(&quot;./ua_method&quot;).UAMethod;
        _private._cache._methods = components.filter(function (obj) {
            return obj instanceof UAMethod;
        });
    }
    return _private._cache._methods;
};

/**
 * returns true if the object has some opcua methods
 * @property hasMethods
 * @type {Boolean}
 */
BaseNode.prototype.__defineGetter__(&quot;hasMethods&quot;, function () {
    return this.getMethods().length &gt; 0;
});

/**
 * @method getMethodById
 * @param nodeId
 * @return {UAMethod|null}
 */
BaseNode.prototype.getMethodById = function (nodeId) {

    const methods = this.getMethods();
    return _.find(methods, function (m) {
        return m.nodeId.toString() === nodeId.toString();
    });
};

function _filter_by_browse_name(components, browseName, namespaceIndex) {
    let select = [];
    if (namespaceIndex === null || namespaceIndex === undefined) {

        select = components.filter(function (c) {
            return c.browseName.name.toString() === browseName;
        });
    } else {
        select = components.filter(function (c) {
            return c.browseName.name.toString() === browseName &amp;&amp; c.browseName.namespaceIndex === namespaceIndex;
        });
    }
    return select;
}

/**
 * @method getMethodByName
 * @param browseName
 * @param [namespaceIndex=null]
 * @return {UAMethod|null}
 */
BaseNode.prototype.getMethodByName = function (browseName, namespaceIndex) {
    assert(typeof browseName === &quot;string&quot;);
    const methods = this.getMethods();
    const select = _filter_by_browse_name(methods, browseName, namespaceIndex);
    assert(select.length &lt;= 1, &quot;BaseNode#getMethodByName found duplicated reference&quot;);
    return select.length === 1 ? select[0] : null;
};

/**
 * returns the nodeId of the Type which is the super type of this
 * @property subtypeOf
 * @type {NodeId}
 */
BaseNode.prototype.__defineGetter__(&quot;subtypeOf&quot;, function subtypeOf() {
    return this.subtypeOfObj ? this.subtypeOfObj.nodeId : null;
});

BaseNode.prototype.__defineGetter__(&quot;subtypeOfObj&quot;, function subtypeOfObj() {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache._subtypeOfObj) {
        const is_subtype_of_ref = this.findReference(&quot;HasSubtype&quot;, false);
        if (is_subtype_of_ref) {
            _private._cache._subtypeOfObj = Reference._resolveReferenceNode(this.addressSpace, is_subtype_of_ref);
        }
    }
    return _private._cache._subtypeOfObj;
});


BaseNode.prototype.__findReferenceWithBrowseName = function (referenceType, browseName) {
    const refs = this.findReferencesAsObject(referenceType);

    function hasBrowseName(node) {
        return node.browseName.toString() === browseName;
    }

    const ref = refs.filter(hasBrowseName)[0];
    return ref;
};


/**
 * @property namespaceIndex
 * @type {Number}
 */
BaseNode.prototype.__defineGetter__(&quot;namespaceIndex&quot;, function () {
    return this.nodeId.namespace;
});

/**
 * @property namespaceUri
 * @type {String}
 */
BaseNode.prototype.__defineGetter__(&quot;namespaceUri&quot;, function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (!_private._cache.namespaceUri) {
        _private._cache.namespaceUri = this.addressSpace.getNamespaceUri(this.namespaceIndex);
    }
    return _private._cache.namespaceUri;
});

/**
 * the parent node
 * @property parent
 * @type {BaseNode}
 */
BaseNode.prototype.__defineGetter__(&quot;parent&quot;, function () {

    const self = this;
    const _private = BaseNode_getPrivate(self);
    if (_private.parent === undefined) {
        _setup_parent_item.call(this, _private._referenceIdx);
    }
    return _private.parent;
});

/**
 * @method resolveNodeId
 * @param nodeId
 * @return {NodeId}
 */
BaseNode.prototype.resolveNodeId = function (nodeId) {
    return this.addressSpace.resolveNodeId(nodeId);
};

BaseNode.prototype._remove_backward_reference = function (reference) {
    const self = this;
    const _private = BaseNode_getPrivate(self);

    assert(reference instanceof Reference);

    _remove_HierarchicalReference(self, reference);
    const h = reference.hash;

    if (_private._back_referenceIdx[h]) {
        // note : h may not exist in _back_referenceIdx since we are not indexing
        //        _back_referenceIdx to UAObjectType and UAVariableType for performance reasons
        _private._back_referenceIdx[h].dispose();
        delete _private._back_referenceIdx[h];
    }
    reference.dispose();
};

BaseNode.prototype._add_backward_reference = function (reference) {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    assert(reference instanceof Reference);
    //xx assert(Reference.is_valid_reference(reference));

    const h = reference.hash;
    assert(_.isString(h));
    // istanbul ignore next
    if (_private._referenceIdx[h]) {
        //  the reference exists already in the forward references
        //  this append for instance when the XML NotSetFile has redundant &lt;Reference&gt;
        //  in this case there is nothing to do
        return;
    }
    // istanbul ignore next
    if (_private._back_referenceIdx[h]) {
        const opts = {addressSpace: self.addressSpace};
        console.warn(&quot; Warning !&quot;, self.browseName.toString());
        console.warn(&quot;    &quot;, reference.toString(opts));
        console.warn(&quot; already found in ===&gt;&quot;);
        console.warn(_.map(_private._back_referenceIdx, c =&gt; c.toString(opts)).join(&quot;\n&quot;));
        console.warn(&quot;===&gt;&quot;);
        throw new Error(&quot;reference exists already in _back_references&quot;);
    }

    if (!reference._referenceType) {
        var w = 1;
    }
    assert(reference._referenceType instanceof ReferenceType);

    _private._back_referenceIdx[h] = reference;
    _handle_HierarchicalReference(self, reference);
    self._clear_caches();

};

let displayWarningReferencePointingToItsef = true;

function _is_massively_used_reference(referenceType) {
    const name = referenceType.browseName.toString();
    return name === &quot;HasTypeDefinition&quot; || name === &quot;HasModellingRule&quot;;

}

function _propagate_ref(self, addressSpace, reference) {

    // filter out non  Hierarchical References
    const referenceType = _resolveReferenceType(addressSpace, reference);

    // istanbul ignore next
    if (!referenceType) {
        console.error(&quot; ERROR&quot;.red, &quot; cannot find reference &quot;, reference.referenceType, reference.toString());
    }

    // ------------------------------- Filter out back reference when reference type
    //                                 is HasTypeDefinition, HasModellingRule, etc ...
    //
    // var referenceNode = Reference._resolveReferenceNode(addressSpace,reference);
    // ignore propagation on back reference to UAVariableType or UAObject Type reference
    // because there are too many !
    if (!referenceType || _is_massively_used_reference(referenceType)) {
        //xx &amp;&amp;(referenceNode.constructor.name === &quot;UAVariableType&quot; || referenceNode.constructor.name  === &quot;UAObjectType&quot;)
        // console.log(referenceType.browseName.toString() ,referenceNode.browseName.toString(), &quot;on &quot;,self.browseName.toString());
        return;
    }
    // ------------------------------- EXPERIMENT


    //xx if (!referenceType.isSupertypeOf(hierarchicalReferencesId)) { return; }
    const related_node = _resolveReferenceNode(addressSpace, reference);
    if (related_node) {

        // verify that reference doesn&#x27;t point to object itself (see mantis 3099)
        if (sameNodeId(reference.nodeId, self.nodeId)) {

            // istanbul ignore next
            if (displayWarningReferencePointingToItsef) {
                // this could happen with method
                console.warn(&quot;  Warning: a Reference is pointing to itself &quot;, self.nodeId.toString(), self.browseName.toString());
                displayWarningReferencePointingToItsef = false;
            }

        }
        //xx ignore this assert(reference.nodeId.toString() !== self.nodeId.toString());
        //function w(s,l) { return (s+&quot;                                                          &quot;).substr(0,l);}
        //if (reference.isForward) {
        //    console.log(&quot;  CHILD =&gt; &quot;,w(related_node.browseName   + &quot; &quot; + related_node.nodeId.toString(),30),
        //        &quot;  PARENT   &quot;,w(self.browseName + &quot; &quot; + self.nodeId.toString(),30) , reference.toString());
        //} else {
        //    console.log(&quot;  CHILD =&gt; &quot;,w(self.browseName   + &quot; &quot; + self.nodeId.toString(),30),
        //        &quot;  PARENT   &quot;,w(related_node.browseName + &quot; &quot; + related_node.nodeId.toString(),30) , reference.toString());
        //
        //}
        related_node._add_backward_reference(new Reference({
            referenceType: reference.referenceType,
            _referenceType: reference._referenceType,
            isForward: !reference.isForward,
            nodeId: self.nodeId,
            node:self
        }));
    } // else addressSpace may be incomplete and under construction (while loading a nodeset.xml file for instance)
}

/**
 * this methods propagates the forward references to the pointed node
 * by inserting backward references to the counter part node
 *
 * @method propagate_back_references
 */
BaseNode.prototype.propagate_back_references = function () {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    if (self.addressSpace.suspendBackReference) {

        // this indicates that the base node is constructed from an xml definition
        // propagate_back_references will be called later once the file has been completely processed.
        return;
    }
    const addressSpace = self.addressSpace;
    for (let reference of _.values(_private._referenceIdx)) {
        _propagate_ref(self, addressSpace, reference);
    }
};


const cetools = require(&quot;./address_space_change_event_tools&quot;);


function _handle_HierarchicalReference(node, reference) {

    const _private = BaseNode_getPrivate(node);
    if (_private._cache._childByNameMap) {
        const addressSpace = node.addressSpace;
        const referenceType = Reference._resolveReferenceType(addressSpace, reference);

        if (referenceType) {

            const HierarchicalReferencesType = addressSpace.findReferenceType(&quot;HierarchicalReferences&quot;);

            //xx console.log (&quot;HierarchicalReferencesType&quot;,HierarchicalReferencesType.toString());
            if (referenceType.isSupertypeOf(HierarchicalReferencesType)) {
                assert(reference.isForward);
                const targetNode = Reference._resolveReferenceNode(addressSpace, reference);
                //Xx console.log(&quot; adding object to map&quot;);
                _private._cache._childByNameMap[targetNode.browseName.name.toString()] = targetNode;
            }
        }
    }
}

function _remove_HierarchicalReference(node, reference) {

    const _private = BaseNode_getPrivate(node);
    if (_private._cache._childByNameMap) {
        const addressSpace = node.addressSpace;
        const referenceType = Reference._resolveReferenceType(addressSpace, reference);

        if (referenceType) {
            const HierarchicalReferencesType = addressSpace.findReferenceType(&quot;HierarchicalReferences&quot;);
            if (referenceType.isSupertypeOf(HierarchicalReferencesType)) {
                assert(reference.isForward);
                const targetNode = Reference._resolveReferenceNode(addressSpace, reference);
                //Xx console.log(&quot; adding object to map&quot;);
                delete _private._cache._childByNameMap[targetNode.browseName.name.toString()];
            }
        }
    }
}

BaseNode.prototype.__addReference = function (reference) {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    assert(reference.hasOwnProperty(&quot;referenceType&quot;));
    //xx isForward is optional : assert(reference.hasOwnProperty(&quot;isForward&quot;));
    assert(reference.hasOwnProperty(&quot;nodeId&quot;));

    const addressSpace = self.addressSpace;
    reference = addressSpace.normalizeReferenceTypes([reference])[0];

    assert(reference instanceof Reference);

    const h = reference.hash;
    assert(!_private._back_referenceIdx[h], &quot;reference exists already in _back_references&quot;);
    assert(!_private._referenceIdx[h], &quot;reference exists already in _references&quot;);

///    self._references.push(reference);
    _private._referenceIdx[h] = reference;
    _handle_HierarchicalReference(self, reference);
    return reference;
};

/**
 * @method addReference
 * @param reference
 * @param reference.referenceType {String}
 * @param [reference.isForward = true] {Boolean}
 * @param reference.nodeId {Node|NodeId|String}
 *
 * @example
 *
 *     view.addReference({ referenceType: &quot;Organizes&quot;, nodeId: myDevice });
 *
 * or
 *
 *     myDevice1.addReference({ referenceType: &quot;OrganizedBy&quot;, nodeId: view });
 */
BaseNode.prototype.addReference = function (reference) {

    const self = this;

    reference = self.__addReference(reference);

    const addressSpace = this.addressSpace;
    if (!_resolveReferenceType(addressSpace, reference)) {
        throw new Error(&quot;BaseNode#addReference : invalid reference  &quot; + reference.toString());
    }
    self._clear_caches();

    _propagate_ref(self, addressSpace, reference);
    self.install_extra_properties();
    cetools._handle_add_reference_change_event(self, reference.nodeId);

};

/***
 * @method removeReference
 * @param reference
 * @return void
 */
BaseNode.prototype.removeReference = function (reference) {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    assert(reference.hasOwnProperty(&quot;referenceType&quot;));
    //xx isForward is optional : assert(reference.hasOwnProperty(&quot;isForward&quot;));
    assert(reference.hasOwnProperty(&quot;nodeId&quot;));

    const addressSpace = self.addressSpace;
    reference = addressSpace.normalizeReferenceTypes([reference])[0];
    const h = reference.hash;

    const relatedNode = addressSpace.findNode(reference.nodeId);

    const invReference = new Reference({
        referenceType: reference.referenceType,
        isForward: !reference.isForward,
        nodeId: self.nodeId
    });


    if (_private._referenceIdx[h]) {
        delete _private._referenceIdx[h];
        relatedNode._remove_backward_reference(invReference);

    } else if (_private._back_referenceIdx[h]) {

        relatedNode.removeReference(invReference);
    } else {
        throw new Error(&quot;Cannot find reference &quot; + reference);
    }

    _handle_HierarchicalReference(self, reference);

    self.uninstall_extra_properties(reference);

    self._clear_caches();

};

/**
 * Undo the effect of propagate_back_references
 * @method unpropagate_back_references
 * @private
 */
BaseNode.prototype.unpropagate_back_references = function () {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    const addressSpace = self.addressSpace;
    //xx assert(addressSpace instanceof AddressSpace);
    _.forEach(_private._referenceIdx, function (reference) {

        // filter out non  Hierarchical References
        const referenceType = _resolveReferenceType(addressSpace, reference);

        // istanbul ignore next
        if (!referenceType) {
            console.error(&quot; ERROR&quot;.red, &quot; cannot find reference &quot;, reference.referenceType, reference.toString());
        }

        const related_node = _resolveReferenceNode(addressSpace, reference);
        if (related_node) {
            assert(reference.nodeId.toString() !== self.nodeId.toString());
            related_node._remove_backward_reference(new Reference({
                referenceType: reference.referenceType,
                isForward: !reference.isForward,
                nodeId: self.nodeId
            }));
        } // else addressSpace may be incomplete

    });
};

BaseNode.prototype._clear_caches = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    _private._cache = {};
};

BaseNode.prototype._on_child_added = function (/*obj*/) {
    const self = this;
    self._clear_caches();
};

BaseNode.prototype._on_child_removed = function (/*obj*/) {
    const self = this;
    self._clear_caches();
};

BaseNode.prototype.getWriteMask = function () {
    return 0;
};

BaseNode.prototype.getUserWriteMask = function () {
    return 0;
};
/**
 * @method readAttribute
 * @param context {SessionContext}
 * @param attributeId {AttributeId}
 * @param [indexRange {NumericRange}]
 * @param [dataEncoding {String}]
 * @return {DataValue}
 */
BaseNode.prototype.readAttribute = function (context, attributeId, indexRange, dataEncoding) {

    assert(context instanceof SessionContext);
    const options = {};
    options.statusCode = StatusCodes.Good;
    switch (attributeId) {

        case AttributeIds.NodeId:  // NodeId
            options.value = {dataType: DataType.NodeId, value: this.nodeId};
            break;

        case AttributeIds.NodeClass: // NodeClass
            assert(_.isFinite(this.nodeClass.value));
            options.value = {dataType: DataType.Int32, value: this.nodeClass.value};
            break;

        case AttributeIds.BrowseName: // QualifiedName
            assert(this.browseName instanceof QualifiedName);
            options.value = {dataType: DataType.QualifiedName, value: this.browseName};
            break;

        case AttributeIds.DisplayName: // LocalizedText
            options.value = {dataType: DataType.LocalizedText, value: this.displayName[0]};
            break;

        case AttributeIds.Description: // LocalizedText
            options.value = {dataType: DataType.LocalizedText, value: this.description};
            break;

        case AttributeIds.WriteMask:
            options.value = {dataType: DataType.UInt32, value: this.getWriteMask()};
            break;

        case AttributeIds.UserWriteMask:
            options.value = {dataType: DataType.UInt32, value: this.getUserWriteMask()};
            break;

        default:
            options.value = null;
            //xx debugLog(&quot;class Name &quot;, this.constructor.name, (&quot; BaseNode : &#x27;&quot; + this.browseName + &quot;&#x27; nodeid=&quot; + this.nodeId.toString()).yellow, &quot; cannot get attribute &quot;, AttributeNameById[attributeId], &quot;(&quot;, attributeId, &quot;)&quot;);
            options.statusCode = StatusCodes.BadAttributeIdInvalid;
            break;
    }
    //xx options.serverTimestamp = new Date();
    return new DataValue(options);
};

/**
 * @method writeAttribute
 * @param context {SessionContext}
 * @param writeValue {Object}
 * @param writeValue.attributeId {AttributeId}
 * @param writeValue.dataValue {DataValue}
 * @param writeValue.indexRange {NumericRange}
 * @param callback {Function}
 * @param callback.err {Error|null}
 * @param callback.statusCode {StatusCode}
 * @async
 */
BaseNode.prototype.writeAttribute = function (context, writeValue, callback) {

    assert(context instanceof SessionContext);
    assert(_.isFunction(callback));

    if (writeValue.attributeId &lt;= 0 || writeValue.attributeId &gt; AttributeIds.UserExecutable) {
        return callback(null, StatusCodes.BadAttributeIdInvalid);
    }
    // by default Node is read-only,
    // this method needs to be overridden to change the behavior
    callback(null, StatusCodes.BadNotWritable);
};


/**
 * @method full_name
 * @return {String} the full path name of the node
 *
 */
BaseNode.prototype.full_name = function () {

    if (this.parentNodeId) {
        const parent = this.addressSpace.findNode(this.parentNodeId);

        // istanbul ignore else
        if (parent) {
            return parent.full_name() + &quot;.&quot; + this.browseName.toString() + &quot;&quot;;
        } else {
            return &quot;NOT YET REGISTERED&quot; + this.parentNodeId.toString() + &quot;.&quot; + this.browseName.toString() + &quot;&quot;;
        }
    }
    return this.browseName.toString();
};

BaseNode.prototype.ownReferences = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    return _.map(_private._referenceIdx);
};
BaseNode.prototype.allReferences = function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    return [].concat(_.map(_private._referenceIdx), _.map(_private._back_referenceIdx));
};


/**
 * @method browseNodeByTargetName
 *
 * @param relativePathElement                           {RelativePathElement}
 * @param relativePathElement.targetName                {QualifiedName}
 * @param relativePathElement.targetName.name           {String}
 * @param relativePathElement.targetName.namespaceIndex {UInt32}
 * @param relativePathElement.referenceTypeId           {NodeId}
 * @param relativePathElement.isInverse                 {Boolean}
 * @param relativePathElement.includeSubtypes           {Boolean}
 *
 * @return {NodeId[]}
 */
BaseNode.prototype.browseNodeByTargetName = function (relativePathElement, isLast) {

    const self = this;
    const _private = BaseNode_getPrivate(self);


    relativePathElement.targetName = relativePathElement.targetName || new QualifiedName();
    // part 4.0 v1.03 $7.26 RelativePath
    // The BrowseName of the target node.
    // The final element may have an empty targetName. In this situation all targets of the references identified by
    // the referenceTypeId are the targets of the RelativePath.
    // The targetName shall be specified for all other elements.
    // The current path cannot be followed any further if no targets with the specified BrowseName exist.
    assert(relativePathElement.targetName instanceof QualifiedName);
    assert(relativePathElement.targetName.namespaceIndex &gt;= 0);
    assert(relativePathElement.targetName.name.length &gt; 0);

    // The type of reference to follow from the current node.
    // The current path cannot be followed any further if the referenceTypeId is not available on the Node instance.
    // If not specified then all References are included and the parameter includeSubtypes is ignored.
    assert(relativePathElement.hasOwnProperty(&quot;referenceTypeId&quot;));

    // Indicates whether the inverse Reference should be followed. The inverse reference is followed if this value is TRUE.
    assert(relativePathElement.hasOwnProperty(&quot;isInverse&quot;));

    //Indicates whether subtypes of the ReferenceType should be followed. Subtypes are included if this value is TRUE.
    assert(relativePathElement.hasOwnProperty(&quot;includeSubtypes&quot;));


    const references = self.allReferences();

    function _check_reference(reference) {

        if (relativePathElement.referenceTypeId.isEmpty()) {
            return true;
        }
        assert(relativePathElement.referenceTypeId instanceof NodeId);
        if ((relativePathElement.isInverse &amp;&amp; reference.isForward) ||
            (!relativePathElement.isInverse &amp;&amp; !reference.isForward)) {
            return false;
        }
        assert(reference.hasOwnProperty(&quot;isForward&quot;));
        const referenceType = _resolveReferenceType(self.addressSpace, reference);
        const referenceTypeId = referenceType.nodeId;

        if (sameNodeId(relativePathElement.referenceTypeId, referenceTypeId)) {
            return true;
        }
        if (relativePathElement.includeSubtypes) {
            const baseType = self.addressSpace.findNode(relativePathElement.referenceTypeId);
            if (baseType &amp;&amp; referenceType.isSupertypeOf(baseType)) {
                return true;
            }
        }
        return false;
    }

    const nodeIdsMap = {};
    let nodeIds = [];

    for (const reference of references) {

        if (!_check_reference(reference)) {
            continue;
        }

        const obj = _resolveReferenceNode(self.addressSpace, reference);

        // istanbul ignore next
        if (!obj) {
            throw new Error(&quot; cannot find node with id &quot;, reference.nodeId.toString());
        }

        if (_.isEqual(obj.browseName, relativePathElement.targetName)) { // compare QualifiedName
            const key = obj.nodeId.toString();
            if (!nodeIdsMap.hasOwnProperty(key)) {
                nodeIds.push(obj.nodeId);
                nodeIdsMap[key] = obj;
            }
        }
    }
    if (self.subtypeOf) {
        // browsing also InstanceDeclarations included in base type
        const baseType = self.addressSpace.findNode(self.subtypeOf);
        const n = baseType.browseNodeByTargetName(relativePathElement, isLast);
        nodeIds = [].concat(nodeIds, n);
    }
    return nodeIds;
};

const check_flag = require(&quot;node-opcua-utils&quot;).check_flag;
const rm = ResultMask;


function _makeReferenceDescription(addressSpace, reference, resultMask) {

    const isForward = reference.isForward;

    const referenceTypeId = _resolveReferenceType(addressSpace, reference).nodeId;
    assert(referenceTypeId instanceof NodeId);

    const obj = _resolveReferenceNode(addressSpace, reference);

    let data = {};

    if (!obj) {
        // cannot find reference node
        data = {
            referenceTypeId: check_flag(resultMask, rm.ReferenceType) ? referenceTypeId : null,
            isForward: isForward,
            nodeId: reference.nodeId
        };
    } else {
        assert(reference.nodeId, obj.nodeId);
        data = {
            referenceTypeId: check_flag(resultMask, rm.ReferenceType) ? referenceTypeId : null,
            isForward: check_flag(resultMask, rm.IsForward) ? isForward : false,
            nodeId: obj.nodeId,
            browseName: check_flag(resultMask, rm.BrowseName) ? coerceQualifyName(obj.browseName) : null,
            displayName: check_flag(resultMask, rm.DisplayName) ? coerceLocalizedText(obj.displayName[0]) : null,
            nodeClass: check_flag(resultMask, rm.NodeClass) ? obj.nodeClass : NodeClass.Unspecified,
            typeDefinition: check_flag(resultMask, rm.TypeDefinition) ? obj.typeDefinition : null
        };
    }
    if (data.typeDefinition === null) {
        data.typeDefinition = resolveNodeId(&quot;i=0&quot;);
    }
    const referenceDescription = new ReferenceDescription(data);
    return referenceDescription;
}

function _constructReferenceDescription(addressSpace, references, resultMask) {
    //x assert(addressSpace instanceof AddressSpace);
    assert(_.isArray(references));
    return references.map(function (reference) {
        return _makeReferenceDescription(addressSpace, reference, resultMask);
    });
}

function referenceTypeToString(addressSpace, referenceTypeId) {

    //istanbul ignore next
    if (!referenceTypeId) {
        return &quot;&lt;null&gt; &quot;;
    } else {
        const referenceType = addressSpace.findNode(referenceTypeId);
        return referenceTypeId.toString() + &quot; &quot; + referenceType.browseName.toString() + &quot;/&quot; + referenceType.inverseName.text;
    }
}

function nodeIdInfo(addressSpace, nodeId) {

    const obj = addressSpace.findNode(nodeId);
    const name = obj ? obj.browseName.toString() : &quot; &lt;????&gt;&quot;;
    return nodeId.toString() + &quot; [ &quot; + name + &quot; ]&quot;;

}

function dumpReferenceDescription(addressSpace, referenceDescription) {

    assert(addressSpace.constructor.name === &quot;AddressSpace&quot;);
    //assert(addressSpace instanceof AddressSpace);
    assert(referenceDescription.referenceTypeId); // must be known;

    console.log(&quot;referenceDescription&quot;.red);
    console.log(&quot;    referenceTypeId : &quot;, referenceTypeToString(addressSpace, referenceDescription.referenceTypeId));
    console.log(&quot;    isForward       : &quot;, referenceDescription.isForward ? &quot;true&quot; : &quot;false&quot;);
    console.log(&quot;    nodeId          : &quot;, nodeIdInfo(addressSpace, referenceDescription.nodeId));
    console.log(&quot;    browseName      : &quot;, referenceDescription.browseName.toString());
    console.log(&quot;    nodeClass       : &quot;, referenceDescription.nodeClass.toString());
    console.log(&quot;    typeDefinition  : &quot;, nodeIdInfo(addressSpace, referenceDescription.typeDefinition));

}

function dumpReferenceDescriptions(addressSpace, referenceDescriptions) {
    assert(addressSpace);
    assert(addressSpace.constructor.name === &quot;AddressSpace&quot;);
    assert(_.isArray(referenceDescriptions));
    referenceDescriptions.forEach(function (r) {
        dumpReferenceDescription(addressSpace, r);
    });
}

exports.dumpReferenceDescription = dumpReferenceDescription;
exports.dumpReferenceDescriptions = dumpReferenceDescriptions;

function nodeid_is_nothing(nodeid) {
    return (nodeid.value === 0 &amp;&amp; nodeid.namespace === 0);
}

/**
 * @method normalize_referenceTypeId
 * @param addressSpace {AddressSpace}
 * @param referenceTypeId {String|NodeId|null} : the referenceType either as a string or a nodeId
 * @return {NodeId}
 */
function normalize_referenceTypeId(addressSpace, referenceTypeId) {
    if (!referenceTypeId) {
        return makeNodeId(0);
    }
    if (typeof referenceTypeId === &quot;string&quot;) {
        const ref = addressSpace.findReferenceType(referenceTypeId);
        if (ref) {
            return ref.nodeId;
        }
    }
    let nodeId;
    try {
        nodeId = addressSpace.resolveNodeId(referenceTypeId);
    }
    catch (err) {
        console.log(&quot;cannot normalize_referenceTypeId&quot;, referenceTypeId);
        throw err;
    }
    assert(nodeId);
    return nodeId;
}

function dumpBrowseDescription(node, browseDescription) {

    const addressSpace = node.addressSpace;

    console.log(&quot; Browse Node :&quot;);

    if (browseDescription.nodeId) {
        console.log(&quot; nodeId : &quot;, browseDescription.nodeId.toString().cyan);
    }

    console.log(&quot; nodeId : &quot;, node.browseName.toString().cyan, &quot;(&quot;, node.nodeId.toString(), &quot;)&quot;);
    console.log(&quot;   referenceTypeId :&quot;, referenceTypeToString(addressSpace, browseDescription.referenceTypeId));

    console.log(&quot;   browseDirection :&quot;, browseDescription.browseDirection.toString().cyan);
    console.log(&quot;   includeSubType  :&quot;, browseDescription.includeSubtypes ? &quot;true&quot; : &quot;false&quot;);
    console.log(&quot;   nodeClassMask   :&quot;, browseDescription.nodeClassMask);
    console.log(&quot;   resultMask      :&quot;, browseDescription.resultMask);
}

/**
 * @method dumpReferences
 * @param addressSpace    {AddressSpace}
 * @param references  {Array&lt;Reference&gt;|null}
 * @static
 */
function dumpReferences(addressSpace, references) {

    assert(addressSpace);

    _.forEach(references, function (reference) {

        const referenceType = Reference._resolveReferenceType(addressSpace, reference);
        if (!referenceType) {
            // unknown type ... this may happen when the address space is not fully build
            return;
        }
        const dir = reference.isForward ? &quot;(=&gt;)&quot; : &quot;(&lt;-)&quot;;
        const objectName = nodeIdInfo(addressSpace, reference.nodeId);

        console.log(&quot; referenceType : &quot;, dir, referenceType ? referenceType.browseName.toString() : reference.referenceType.toString(), &quot; &quot;, objectName);
    });
}

exports.dumpBrowseDescription = dumpBrowseDescription;
exports.dumpReferences = dumpReferences;

const _resolveReferenceNode = Reference._resolveReferenceNode;
const _resolveReferenceType = Reference._resolveReferenceType;


function _filter_by_referenceType(self, browseDescription, references, referenceTypeId) {

    // make sure we have a valid referenceTypeId if not null
    if (!nodeid_is_nothing(referenceTypeId)) {

        assert(referenceTypeId instanceof NodeId);
        const referenceType = self.addressSpace.findNode(referenceTypeId);

        dumpIf(!referenceType, referenceTypeId);
        assert(referenceType instanceof ReferenceType);

        references = references.filter(function (reference) {

            const ref = _resolveReferenceType(self.addressSpace, reference);

            if (!ref) {
                return false;
            } // unknown type ... this may happen when the address space is not fully build
            assert(ref instanceof ReferenceType);

            const is_of_type = ref.nodeId.toString() === referenceType.nodeId.toString();
            if (is_of_type) {
                return true;
            }
            if (browseDescription.includeSubtypes) {
                return ref.isSupertypeOf(referenceType);
            } else {
                return false;
            }
        });
    }
    return references;
}

function forwardOnly(reference) {
    return reference.isForward;
}

function reverseOnly(reference) {
    return !reference.isForward;
}

function _filter_by_direction(references, browseDirection) {

    if (browseDirection === BrowseDirection.Both) {
        return references;
    }
    if (browseDirection === BrowseDirection.Forward) {
        return references.filter(forwardOnly);
    } else {
        return references.filter(reverseOnly);
    }
}


function _filter_by_nodeclass(self, references, nodeClassMask) {

    assert(_.isFinite(nodeClassMask));
    if (nodeClassMask === 0) {
        return references;
    }
    const addressSpace = self.addressSpace;
    return references.filter(function (reference) {

        const obj = _resolveReferenceNode(addressSpace, reference);

        if (!obj) {
            return false;
        }

        const nodeClassName = obj.nodeClass.key;

        const value = makeNodeClassMask(nodeClassName);
        return (value &amp; nodeClassMask) === value;

    });
}

function _filter_by_userFilter(self, references, session) {

    const addressSpace = self.addressSpace;
    return references.filter(function (reference) {

        const obj = _resolveReferenceNode(addressSpace, reference);

        if (!obj) {
            return false;
        }

        return (obj._browseFilter(session));
    });
}

/**
 * browse the node to extract information requested in browseDescription
 * @method browseNode
 * @param browseDescription                 {BrowseDescription}
 * @param browseDescription.referenceTypeId {NodeId}
 * @param browseDescription.browseDirection {BrowseDirection}
 * @param browseDescription.nodeClassMask   {NodeClassMask}
 * @param browseDescription.resultMask      {UInt32}
 * @param session                           {ServerSession}
 * @return {ReferenceDescription[]}
 */
BaseNode.prototype.browseNode = function (browseDescription, session) {

    assert(_.isFinite(browseDescription.nodeClassMask));
    assert(_.isObject(browseDescription.browseDirection));

    const do_debug = false;

    //xx do_debug = ( this.browseName === &quot;Server&quot; );

    const self = this;
    const _private = BaseNode_getPrivate(self);

    const referenceTypeId = normalize_referenceTypeId(this.addressSpace, browseDescription.referenceTypeId);
    assert(referenceTypeId instanceof NodeId);

    const browseDirection = browseDescription.browseDirection || BrowseDirection.Both;

    const addressSpace = self.addressSpace;

    // get all possible references
    let references = [].concat(_.map(_private._referenceIdx), _.map(_private._back_referenceIdx));

    /* istanbul ignore next */
    if (do_debug) {
        console.log(&quot;all references :&quot;, self.nodeId.toString(), self.browseName.toString());
        dumpReferences(addressSpace, _.map(_private._referenceIdx));
    }

    // filter out references not matching referenceType
    references = _filter_by_referenceType(self, browseDescription, references, referenceTypeId);

    references = _filter_by_direction(references, browseDirection);

    references = _filter_by_nodeclass(self, references, browseDescription.nodeClassMask);

    references = _filter_by_userFilter(self, references, session);

    const referenceDescriptions = _constructReferenceDescription(addressSpace, references, browseDescription.resultMask);

    /* istanbul ignore next */
    if (do_debug) {
        dumpReferenceDescriptions(self.addressSpace, referenceDescriptions);
    }

    return referenceDescriptions;
};

/*
 * install hierarchical references as javascript properties
 * Components/Properties/Organizes
 */
function install_components_as_object_properties(parentObj) {

    if (!parentObj) {
        return;
    }

    const addressSpace = parentObj.addressSpace;
    const hierarchicalRefs = parentObj.findHierarchicalReferences();

    const children = hierarchicalRefs.map(function (r) {
        return _resolveReferenceNode(addressSpace, r);
    });


    for (const child of children) {

        if (!child) {
            continue;
        }
        // assumption: we ignore namespace here .
        const name = lowerFirstLetter(child.browseName.name.toString());


        if (reservedNames.hasOwnProperty(name)) {
            if (doDebug) {
                console.log((&quot;Ignoring reserved keyword                                               &quot; + name).bgWhite.red);
            }
            continue;
        }


        if (doDebug) {
            console.log(&quot;Installing property &quot; + name, &quot; on &quot;, parentObj.browseName.toString());
        }

        /* istanbul ignore next */
        if (parentObj.hasOwnProperty(name)) {
            continue;
        }

        Object.defineProperty(parentObj, name, {
            enumerable: true,
            configurable: true, // set to true, so we can undefine later
            //xx writable: false,
            get: function () {
                return child;
            }
            //value: child
        });
    }
}

BaseNode.prototype.install_extra_properties = function () {

    const self = this;
    const addressSpace = self.addressSpace;

    if (addressSpace.isFrugal) {
        // skipping
        return;
    }

    install_components_as_object_properties(self);

    function install_extra_properties_on_parent(ref) {
        const node = Reference._resolveReferenceNode(addressSpace, ref);
        install_components_as_object_properties(node);
    }

    // make sure parent have extra properties updated
    const parentComponents = self.findReferences(&quot;HasComponent&quot;, false);
    const parentSubfolders = self.findReferences(&quot;Organizes&quot;, false);
    const parentProperties = self.findReferences(&quot;HasProperty&quot;, false);
    parentComponents.forEach(install_extra_properties_on_parent);
    parentSubfolders.forEach(install_extra_properties_on_parent);
    parentProperties.forEach(install_extra_properties_on_parent);
};


BaseNode.prototype.uninstall_extra_properties = function (reference) {
    const self = this;
    const addressSpace = self.addressSpace;

    if (addressSpace.isFrugal) {
        // skipping
        return;
    }
    const childNode = _resolveReferenceNode(addressSpace, reference);

    const name = lowerFirstLetter(childNode.browseName.name.toString());
    if (reservedNames.hasOwnProperty(name)) {
        if (doDebug) {
            console.log((&quot;Ignoring reserved keyword                                               &quot; + name).bgWhite.red);
        }
        return;
    }
    /* istanbul ignore next */
    if (!self.hasOwnProperty(name)) {
        return;
    }

    Object.defineProperty(self, name, {
        value: undefined
    });
};


function _clone_collection_new(newParent, collectionRef, optionalFilter, extraInfo) {

    const addressSpace = newParent.addressSpace;
    assert(!optionalFilter || (_.isFunction(optionalFilter.shouldKeep) &amp;&amp; _.isFunction(optionalFilter.filterFor)));

    for (let reference of collectionRef) {

        const node = _resolveReferenceNode(addressSpace, reference);

        // ensure node is of the correct type,
        // it may happen that the xmlnodeset2 file was malformed

        // istanbul ignore next
        if (!_.isFunction(node.clone)) {
            console.log(&quot;Warning : cannot clone node &quot;.red + node.browseName.toString() + &quot; of class &quot; + node.nodeClass.toString(), &quot; while cloning &quot;, newParent.browseName.toString());
            continue;
        }

        if (optionalFilter &amp;&amp; !optionalFilter.shouldKeep(node)) {
            continue; // skip this node
        }

        assert(reference.isForward);
        assert(reference.referenceType instanceof NodeId, &quot;&quot; + reference.referenceType.toString());
        const options = {
            references: [
                {referenceType: reference.referenceType, isForward: false, nodeId: newParent.nodeId}
            ]
        };

        const clone = node.clone(options, optionalFilter, extraInfo);

        /// clone.propagate_back_references();

        if (extraInfo) {
            extraInfo.registerClonedObject(node, clone);
        }
    }
}

/**
 * clone properties and methods
 * @method _clone_children_references
 * @param newParent the new parent object to which references of type HasChild  will be attached
 * @param [optionalFilter {Function} = null] a filter
 * @param [extraInfo]
 * @return {Array}
 * @private
 */
BaseNode.prototype._clone_children_references = function (newParent, optionalFilter, extraInfo) {

    const self = this;
    assert(newParent instanceof BaseNode);
    // find all reference that derives from the Aggregates
    const aggregatesRef = self.findReferencesEx(&quot;Aggregates&quot;, BrowseDirection.Forward);
    _clone_collection_new(newParent, aggregatesRef, optionalFilter, extraInfo);

};

/**
 * @method _clone
 * @param Constructor {Function}
 * @param options {Object}
 * @param extraInfo
 * @param optionalFilter
 * @return {*}
 * @private
 */
BaseNode.prototype._clone = function (Constructor, options, optionalFilter, extraInfo) {

    const Namespace = require(&quot;./namespace&quot;).Namespace;

    const self = this;

    assert(_.isFunction(Constructor));
    assert(_.isObject(options));
    assert(!extraInfo || (_.isObject(extraInfo) &amp;&amp; _.isFunction(extraInfo.registerClonedObject)));
    assert(!self.subtypeOf, &quot;We do not do cloning of Type yet&quot;);

    options = _.extend(options, {
        addressSpace: self.addressSpace,
        browseName: self.browseName,
        displayName: self.displayName,
        description: self.description
    });
    options.references = options.references || [];

    if (self.typeDefinition) {
        options.references.push({referenceType: &quot;HasTypeDefinition&quot;, isForward: true, nodeId: self.typeDefinition});
    }

    if (!options.modellingRule) {
        if (self.modellingRule) {
            const modellingRuleNode = self.findReferencesAsObject(&quot;HasModellingRule&quot;)[0];
            assert(modellingRuleNode);
            options.references.push({
                referenceType: &quot;HasModellingRule&quot;,
                isForward: true,
                nodeId: modellingRuleNode.nodeId
            });
        }
    } else {
        Namespace._process_modelling_rule(options.references, options.modellingRule);
    }

    options.nodeId = self.addressSpace.getOwnNamespace()._construct_nodeId(options);

    assert(options.nodeId instanceof NodeId);

    const cloneObj = new Constructor(options);
    self.addressSpace._register(cloneObj);

    const newFilter = optionalFilter ? optionalFilter.filterFor(cloneObj) : null;
    self._clone_children_references(cloneObj, newFilter, extraInfo);

    cloneObj.propagate_back_references();

    cloneObj.install_extra_properties();

    return cloneObj;

};

function indent(str, padding) {
    padding = padding || &quot;          &quot;;
    return str.split(&quot;\n&quot;).map(function (r) {
        return padding + r;
    }).join(&quot;\n&quot;);
}


BaseNode.prototype.toString = function (options) {

    const str = [];
    const self = this;

    if (options) {
        assert(_.isObject(options.cycleDetector));
    }
    options = options || {};

    function add(s) {
        str.push(s);
    }

    options.add = add;
    options.indent = indent;
    options.padding = options.padding || &quot; &quot;;
    options.cycleDetector = options.cycleDetector || {};

    self._toString(str, options);

    return str.join(&quot;\n&quot;);
};

const hasTypeDefinition_ReferenceTypeNodeId = resolveNodeId(&quot;HasTypeDefinition&quot;);

BaseNode.prototype._toString = function (str, options) {

    assert(_.isArray(str));

    options.level = options.level || 1;

    const add = options.add;
    const indent = options.indent;

    const self = this;
    const _private = BaseNode_getPrivate(self);


    function set_as_processed(nodeId) {
        assert(nodeId instanceof NodeId);
        options.cycleDetector[nodeId.toString()] = nodeId;
    }

    set_as_processed(self.nodeId);

    function is_already_processed(nodeId) {
        return !!options.cycleDetector[nodeId.toString()];
    }


    add(&quot;&quot;);
    add(options.padding + &quot;          nodeId        : &quot;.yellow + self.nodeId.toString());
    add(options.padding + &quot;          nodeClass     : &quot;.yellow + self.nodeClass.toString());
    add(options.padding + &quot;          browseName    : &quot;.yellow + self.browseName.toString());
    add(options.padding + &quot;          displayName   : &quot;.yellow + self.displayName.map(function (f) {
        return f.locale + &quot; &quot; + f.text;
    }).join(&quot; | &quot;));

    add(options.padding + &quot;          description   : &quot;.yellow + (self.description ? self.description.toString() : &quot;&quot;));


    if (self.dataType) {

        const addressSpace = self.addressSpace;
        const d = addressSpace.findNode(self.dataType);
        const n = d ? &quot;(&quot; + d.browseName.toString() + &quot;)&quot; : &quot; (???)&quot;;
        add(options.padding + &quot;                dataType: &quot;.yellow + self.dataType + &quot;  &quot; + n);
    }
    if (self._dataValue) {
        add(options.padding + &quot;                   value: &quot;.yellow + &quot;\n&quot; + indent(self._dataValue.toString(), options.padding + &quot;                        | &quot;));
    }
    if (self.subtypeOfObj) {
        add(options.padding + &quot;               subtypeOf: &quot;.yellow + &quot; &quot; + self.subtypeOfObj.nodeId.toString() + &quot; &quot; + self.subtypeOfObj.browseName.toString());
    }
    if (self.typeDefinitionObj) {
        add(options.padding + &quot;          typeDefinition: &quot;.yellow + &quot; &quot; + self.typeDefinitionObj.nodeId.toString() + &quot; &quot; + self.typeDefinitionObj.browseName.toString());
    }

    if (self.accessLevel) {
        add(options.padding + &quot;             accessLevel: &quot;.yellow + &quot; &quot; + self.accessLevel.toString());
    }
    if (self.userAccessLevel) {
        add(options.padding + &quot;         userAccessLevel: &quot;.yellow + &quot; &quot; + self.userAccessLevel.toString());
    }
    if (self.hasOwnProperty(&quot;valueRank&quot;)) {
        add(options.padding + &quot;               valueRank: &quot;.yellow + &quot; &quot; + self.valueRank.toString());
    }
    if (self.minimumSamplingInterval !== undefined) {
        add(options.padding + &quot; minimumSamplingInterval: &quot;.yellow + &quot; &quot; + self.minimumSamplingInterval.toString() + &quot; ms&quot;);
    }


    add(options.padding + &quot;          references    : &quot;.yellow + &quot;  length =&quot; + Object.keys(_private._referenceIdx).length);

    const dispOptions = {
        addressSpace: self.addressSpace
    };


    function dump_reference(follow, reference) {
        //xx if (!reference.isForward) {
        //xx     return;
        //xx }
        const o = _resolveReferenceNode(self.addressSpace, reference);
        const name = o ? o.browseName.toString() : &quot;&lt;???&gt;&quot;;
        add(options.padding + &quot;               +-&gt; &quot;.yellow + reference.toString(dispOptions) + &quot; &quot; + name.cyan);

        // ignore HasTypeDefinition as it has been already handled
        if (sameNodeId(reference.referenceType, hasTypeDefinition_ReferenceTypeNodeId) &amp;&amp; reference.nodeId.namespace === 0) {
            return;
        }
        if (o) {
            if (!is_already_processed(o.nodeId)) {
                set_as_processed(o.nodeId);
                if (options.level &gt; 1 &amp;&amp; follow) {
                    const rr = o.toString({
                        level: options.level - 1,
                        padding: options.padding + &quot;         &quot;,
                        cycleDetector: options.cycleDetector
                    });
                    add(rr);
                }
            }
        }
    }

    // direct reference
    _.forEach(_private._referenceIdx, dump_reference.bind(null, true));

    const br = _.map(_private._back_referenceIdx);
    add(options.padding + &quot;         back_references: &quot;.yellow + &quot;  length =&quot; + br.length + &quot; ( references held by other nodes involving this node)&quot;.grey);
    // backward reference
    br.forEach(dump_reference.bind(null, false));

};

/**
 * the dispose method should be called when the node is no longer used, to release
 * back pointer to the address space and clear caches.
 *
 * @method dispose
 *
 */
BaseNode.prototype.dispose = function () {

    const self = this;
    const _private = BaseNode_getPrivate(self);

    self.emit(&quot;dispose&quot;);

    self.removeAllListeners();
    self._clear_caches();

    _.forEach(_private._back_referenceIdx, function (ref) {
        ref.dispose();
    });
    _.forEach(_private._referenceIdx, function (ref) {
        ref.dispose();
    });
    _private._cache = {};
    _private.__address_space = null;
    _private._back_referenceIdx = null;
    _private._referenceIdx = null;

};


exports.BaseNode = BaseNode;
ReferenceType = require(&quot;./referenceType&quot;).ReferenceType;


/**
 * @property modellingRule
 * @type {String|undefined}
 */
BaseNode.prototype.__defineGetter__(&quot;modellingRule&quot;, function () {
    const node = this;
    let r = node.findReferencesAsObject(&quot;HasModellingRule&quot;);
    if (!r || r.length === 0) {
        return null; ///&quot;? modellingRule missing ?&quot;; // consider &quot;Mandatory&quot;
    }
    r = r[0];
    return r.browseName.toString();
});

/**
 * @property isTrueSubStateOf
 * @type {BaseNode|null}
 */
BaseNode.prototype.__defineGetter__(&quot;isTrueSubStateOf&quot;, function () {
    const node = this;
    let r = node.findReferencesAsObject(&quot;HasTrueSubState&quot;, false);
    if (!r || r.length === 0) {
        return null;
    }
    assert(r.length === 1);
    r = r[0];
    return r;
});
/**
 * @property isFalseSubStateOf
 * @type {BaseNode|null}
 */
BaseNode.prototype.__defineGetter__(&quot;isFalseSubStateOf&quot;, function () {
    const node = this;
    let r = node.findReferencesAsObject(&quot;HasFalseSubState&quot;, false);
    if (!r || r.length === 0) {
        return null;
    }
    assert(r.length === 1);
    r = r[0];
    return r;
});


/**
 * @method getFalseSubStates
 * @return {BaseNode[]} return an array with the SubStates of this object.
 */
BaseNode.prototype.getFalseSubStates = function () {
    return this.findReferencesAsObject(&quot;HasFalseSubState&quot;);
};

/**
 * @method getTrueSubStates
 * @return {BaseNode[]} return an array with the SubStates of this object.
 */
BaseNode.prototype.getTrueSubStates = function () {
    return this.findReferencesAsObject(&quot;HasTrueSubState&quot;);
};


BaseNode.prototype.findHierarchicalReferences = function () {

    const node = this;
    return node.findReferencesEx(&quot;HierarchicalReferences&quot;, BrowseDirection.Forward);
    // const _private = BaseNode_getPrivate(node);
    //
    // if (!_private._cache._HasChildReferences) {
    //     //xx console.log(&quot;node &quot;,node.nodeId.toString());
    //     //xx _private._cache._HasChildReferences =  node.findReferencesEx(&quot;HierarchicalReferences&quot;,BrowseDirection.Forward);
    //     const r1 =
    //     const r2 = node.findReferencesEx(&quot;Organizes&quot;,BrowseDirection.Forward);
    //     _private._cache._HasChildReferences = r1.concat(r2);
    // }
    // return _private._cache._HasChildReferences;
};

BaseNode.prototype.getChildByName = function (browseName) {

    // Attention: getChild doesn&#x27;t care about namespace on browseName
    //            !!!!
    if (browseName instanceof QualifiedName) {
        browseName = browseName.name.toString();
    }
    assert(typeof browseName === &quot;string&quot;);
    const node = this;
    const _private = BaseNode_getPrivate(node);

    const addressSpace = node.addressSpace;

    if (!_private._cache._childByNameMap) {
        _private._cache._childByNameMap = {};

        const childReferenceTypes = node.findReferencesEx(&quot;HasChild&quot;);
        for (let r of childReferenceTypes) {
            const child = _resolveReferenceNode(addressSpace, r);
            _private._cache._childByNameMap[child.browseName.name.toString()] = child;
        }

    }
    const ret = _private._cache._childByNameMap[browseName] || null;
    return ret;
};


BaseNode.prototype.__defineGetter__(&quot;addressSpace&quot;, function () {
    const self = this;
    const _private = BaseNode_getPrivate(self);
    return _private.__address_space;
});

BaseNode.prototype.__defineGetter__(&quot;namespace&quot;, function () {
    const self = this;
    return self.addressSpace.getNamespace(self.nodeId.namespace);
});

BaseNode.prototype.installPostInstallFunc = function (f) {

    if (!f) {
        // nothing to do
        return;
    }
    const self = this;

    function chain(f1, f2) {
        return function () {
            const args = arguments;
            if (f1) {
                f1.apply(this, args);
            }
            if (f2) {
                f2.apply(this, args);
            }
        };
    }

    self._postInstantiateFunc = chain(self._postInstantiateFunc, f);
};

    </pre>
</div>
                    </div>
                </div>
            </div>
            <!-- Ad by Google -->
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-format="fluid"
                 data-ad-layout-key="-8h+1u-de+eo+dy"
                 data-ad-client="ca-pub-8886208393040088"
                 data-ad-slot="9362364253"></ins>
            <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
            </script>
            <!-- -->

        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
